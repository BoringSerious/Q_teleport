<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superdense Coding - level 4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f0f0f0;
            height: 1vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content {
            flex: 1;
            padding: 10px;
            background: none;
            overflow: hidden;
        }

        .block {
            display: none;
            height: 100%;
            border: 1px solid #ccc;
            box-shadow: 0 4px 16px 0 rgba(0,0,0,0.15), 0 1.5px 4px 0 rgba(0,0,0,0.10);
            background-color: #fffff0;
            overflow: hidden;
        }

        .block.active {
            display: block;
        }

        .block h2 {
            color: #2f4f78;
            margin: 10px;
            font-size: 18px;
            font-weight: bold;
            background: rgba(255,255,255,0.85);
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }

        .block-content {
            padding: 10px;
            height: calc(100% - 50px);
            overflow: hidden;
        }

        .highlight {
            background: #ffe9b3;
            color: #333;
            padding: 10px;
            border: 1px solid #ccc;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .card {
            background: #fffff0;
            padding: 10px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #2f4f78;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .card p {
            color: #333;
            font-size: 12px;
        }

        /* Block 1 ä½ˆå±€ */
        .block1-layout {
            display: flex;
            gap: 5px;
            height: 100%;
            width: 100%;
        }

        /* å·¦å´å€åŸŸ */
        .left-panel {
            width: 66.67%;
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0;
        }

        /* Monitor å€åŸŸ */
        #monitor {
            height: 25%;
            background: #fffff0;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* Monitor å…§éƒ¨ä½ˆå±€ */
        .monitor-layout {
            display: flex;
            gap: 10px;
            width: 100%;
            height: 100%;
        }
        
        /* å·¦å´ Descriptor å€åŸŸ */
        .descriptor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* å³å´ Pass Hints å€åŸŸ */
        .expectation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* Monitor å­å€å¡Šæ¨£å¼ */
        .monitor-block {
            flex: 1;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .monitor-block h4 {
            margin: 0 0 5px 0;
            font-size: 12px;
            color: #2f4f78;
            font-weight: bold;
        }
        
        .monitor-block .content {
            flex: 1;
            font-size: 15px;
            color: #333;
            overflow-y: auto;
        }
        
        /* Run Button æ¨£å¼ */
        .run-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
            margin-left: 10px;
            flex-shrink: 0;
        }
        
        .run-button:hover {
            background: #45a049;
        }
        
        .run-button:active {
            background: #3d8b40;
        }
        
        /* Monitor å…§å®¹å€åŸŸ */
        .monitor-content {
            flex: 1;
            overflow-y: auto;
        }

        /* Three.js å®¹å™¨æ¨£å¼ */
        #game-container {
            height: 75%;
            background: #f0f0f0;
            border: 1px solid #ccc;
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* æ–‡å­—å…§å®¹å€åŸŸ */
        #text-content {
            width: 33.33%;
            background: #ffe9b3;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }
        
        #text-content.collapsed {
            width: 50px;
            overflow: hidden;
        }
        
        #text-content.collapsed .content-label {
            transform: rotate(90deg);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        
        /* åˆ‡æ›æŒ‰éˆ•æ¨£å¼ */
        .toggle-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #0b538f;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: background-color 0.3s;
            z-index: 15;
        }
        
        .toggle-button:hover {
            background: #094076;
        }
        
        /* å€åŸŸæ¨™ç±¤æ¨£å¼ */
        .area-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(47, 79, 120, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        .content-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(47, 79, 120, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        
        /* Reset Button æ¨£å¼ */
        .reset-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #f44336;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
            z-index: 10;
        }
        
        .reset-button:hover {
            background: #d32f2f;
        }
        
        .reset-button:active {
            background: #b71c1c;
        }
        
        /* Time Step Display æ¨£å¼ */
        .time-step-display {
            position: absolute;
            top: 5px;
            right: 70px;
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            min-width: 50px;
            text-align: center;
        }
        
        /* èª¿æ•´å®¹å™¨ç‚ºç›¸å°å®šä½ä»¥æ”¯æŒçµ•å°å®šä½çš„æ¨™ç±¤ */
        #monitor, #game-container, #text-content {
            position: relative;
        }
        
        /* Classical bits å®¹å™¨æ¨£å¼ */
        .classical-bits-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 20;
        }
        
        /* Classical bit block æ¨£å¼ */
        .classical-bit-block {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #2f4f78;
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
            text-align: center;
        }
        
        .classical-bit-block:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .classical-bit-block:active {
            transform: translateY(0);
        }
        
        /* Bit title æ¨£å¼ */
        .bit-title {
            font-size: 15px;
            color: #2f4f78;
            font-weight: 900;
            margin-bottom: 4px;
        }
        
        /* Bit value æ¨£å¼ */
        .bit-value {
            font-size: 20px;
            color: #333;
            font-weight: bold;
            font-family: Georgia, serif;
            font-style: italic;
        }
        
        /* Check button æ¨£å¼ */
        .check-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .check-button:hover {
            background: #45a049;
        }
        
        .check-button:active {
            background: #3d8b40;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="block active" id="block0">
                <h2 style="font-family: Georgia, serif; font-size: 20px;">Level 4 - <span style="background: linear-gradient(45deg, #ff6b6b, #ffa500); color: white; padding: 4px 8px; border-radius: 6px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Normal Challenge!</span> Transmitting Two-bits Information with Superdense Coding</h2>
                <div class="block-content">
                    <div class="block1-layout">
                        <div class="left-panel">
                            <div id="monitor">
                                <!-- <div class="area-label">Monitor</div> -->
                                <div class="monitor-layout">
                                    <div class="descriptor-panel">
                                        <div class="monitor-block">
                                            <h4>Descriptor Q1</h4>
                                            <div class="content">
                                                <!-- Descriptor 1 å…§å®¹ -->
                                                <p>
                                                  Q1 = (X1,Z1)
                                                </p>
                                            </div>
                                        </div>
                                        <div class="monitor-block">
                                            <h4>Descriptor Q2</h4>
                                            <div class="content">
                                                <!-- Descriptor 2 å…§å®¹ -->
                                                <p>
                                                  Q2 = (X2,Z2)
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="expectation-panel">
                                        <div class="monitor-block">
                                            <h4>Expectation Value Q1</h4>
                                            <div class="content">
                                                <!-- Expectation Value 1 å…§å®¹ -->
                                                <p>
                                                  Exc.X(Q1) = 0,    Exc.Z(Q1) = 1
                                                </p>
                                            </div>
                                        </div>
                                        <div class="monitor-block">
                                            <h4>Expectation Value Q2</h4>
                                            <div class="content">
                                                <!-- Expectation Value 2 å…§å®¹ -->
                                                <p>
                                                  Exc.X(Q2) = 0,    Exc.Z(Q2) = 1
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button class="run-button" onclick="runSimulation()">Run</button>
                            </div>
                            <div id="game-container">
                                <div class="area-label">Game Area</div>
                                <div class="time-step-display" id="time-step-display">t = 0</div>
                                <button class="reset-button" onclick="resetSimulation()">Reset</button>
                                
                                <!-- å³ä¸‹è§’çš„classical bitså€åŸŸ -->
                                <div class="classical-bits-container">
                                    <div class="classical-bit-block" onclick="toggleBit('i')">
                                        <div class="bit-title">Classical bit of "i"</div>
                                        <div class="bit-value" id="bit-i">i = ?</div>
                                    </div>
                                    <div class="classical-bit-block" onclick="toggleBit('j')">
                                        <div class="bit-title">Classical bit of "j"</div>
                                        <div class="bit-value" id="bit-j">j = ?</div>
                                    </div>
                                    <button class="check-button" onclick="checkAnswer()">Check</button>
                                </div>
                                
                                <canvas id="game-canvas"></canvas>
                            </div>
                        </div>
                        <div id="text-content" class="collapsed">
                            <div class="content-label">Tips</div>
                            <button class="toggle-button" onclick="toggleTextContent()">Show</button>
                            <div class="text-content-inner" style="margin-top: 40px; padding: 10px; display: none;">
                                <h3 style="color: #2f4f78; margin-bottom: 15px;">Challenge: Classical Bits Decryption</h3>
                                
                                <p style="margin-bottom: 10px; line-height: 1.5;">
                                    This challenge aims to simulate the reception of two classical bits from one qubit. 
                                    Suppose there are two qubits(Q1, Q2), and Q1 is encoded with two classical bits information (i, j).
                                    through "Ïƒxâ±" and "ÏƒzÊ²" gates. How can we extract the classical bits by using entanglement and joint measurement?
                                </p>
                                
                                <button class="instructions-toggle" onclick="toggleInstructions()" style="background: #2f4f78; color: white; border: none; padding: 1px 2px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; margin: 15px 0 8px 0;">Introduction â–¼</button>
                                <div id="instructions-content" style="display: none; margin-left: 20px;">
                                    <ul style="margin-left: 20px; line-height: 1.4;">
                                        <li>Suppose two qubits Q1, Q2 are entangled and separated from a long distance, where Alice holds Q1 and Bob holds Q2.</li>
                                        <li>Alice stores the i, j information into Q1 by Pauli "Ïƒx(i)" and "Ïƒz(j)" gates.</li>
                                        <li>Then Bob receives the Q1 from Alice, and perform Bell measurement on Q1 and Q2 to extract the i, j information.</li>
                                        <li>Therefore, this simulation shows the possibility of transmitting two classical bits through one quantum bit.</li>
                                    </ul>
                                </div>
                                <br>
                                <button class="expectation-toggle" onclick="toggleExpectation()" style="background: #2f4f78; color: white; border: none; padding: 1px 2px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; margin: 15px 0 8px 0;">Pass Hints â–¼</button>
                                <div id="expectation-content" style="display: none; margin-left: 20px;">
                                    <ul style="margin-left: 20px; line-height: 1.4;">
                                        <li>This simulation can be achieved by Bell state formation and Bell measurement.</li>
                                        <li>The information of i and j could be reasoned by the expectation values of the descriptor.</li>
                                        <li>Try not to guess the answer. ğŸ¤«</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleExpectation() {
            const expectationContent = document.getElementById('expectation-content');
            const toggleButton = document.querySelector('.expectation-toggle');
            
            if (expectationContent.style.display === 'none') {
                // å±•é–‹
                expectationContent.style.display = 'block';
                toggleButton.textContent = 'Pass Hints â–²';
            } else {
                // æ”¶èµ·
                expectationContent.style.display = 'none';
                toggleButton.textContent = 'Pass Hints â–¼';
            }
        }

        function showBlock(blockIndex) {
            // éš±è—æ‰€æœ‰å€å¡Š
            const blocks = document.querySelectorAll('.block');
            blocks.forEach(block => {
                block.classList.remove('active');
            });

            // ç§»é™¤æ‰€æœ‰tabçš„activeç‹€æ…‹
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            // é¡¯ç¤ºé¸ä¸­çš„å€å¡Š
            document.getElementById(`block${blockIndex}`).classList.add('active');
            
            // æ¿€æ´»é¸ä¸­çš„tab
            tabs[blockIndex].classList.add('active');
        }
        
        // åˆ‡æ› Text Content é¡¯ç¤º/éš±è—
        function toggleTextContent() {
            const textContent = document.getElementById('text-content');
            const textContentInner = textContent.querySelector('.text-content-inner');
            const toggleButton = textContent.querySelector('.toggle-button');
            
            if (textContent.classList.contains('collapsed')) {
                // å±•é–‹
                textContent.classList.remove('collapsed');
                textContentInner.style.display = 'block';
                toggleButton.textContent = 'Hide';
            } else {
                // æ”¶èµ·
                textContent.classList.add('collapsed');
                textContentInner.style.display = 'none';
                toggleButton.textContent = 'Show';
            }
        }

        // Three.js éŠæˆ²åˆå§‹åŒ–
        let scene, camera, renderer, boxes = [];
        let raycaster, mouse;
        let animationId;
        let t = 0; // ç•¶å‰æ™‚é–“æ­¥ï¼Œé»˜èª0
        
        function initGame() {
            const container = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            
            // å‰µå»ºå ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // å‰µå»ºç›¸æ©Ÿ - ä½¿ç”¨é•·ç„¦é¡é ­å¯¦ç¾å¹³é¢3Dæ•ˆæœï¼Œå¾æ­£æ–¹å½¢é ‚é»çœ‹å‘åŸé»
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(22, aspect, 0.1, 1000); // 20åº¦è¦–è§’ = é•·ç„¦
            camera.position.set(-10, 20, 20); // ç§»å‹•åˆ°æ­£æ–¹å½¢é ‚é»ï¼ŒYä¿æŒä¸è®Š
            camera.lookAt(0, 0, 0);
            
            // å‰µå»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // æ·»åŠ ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // æ·»åŠ åæ¨™è»¸
            //createAxes();
            
            // å‰µå»ºboxes
            createBoxes();
            
            // å‰µå»ºåº•éƒ¨bars
            createBottomBars();
            
            // åˆå§‹åŒ–äº’å‹•
            initInteraction();
            
            // é–‹å§‹æ¸²æŸ“å¾ªç’°
            animate();
        }
        

        
        function createAxes() {
            // å‰µå»ºåæ¨™è»¸
            const axesHelper = new THREE.AxesHelper(3);
            axesHelper.position.set(0, 0, 0); // æ”¾åœ¨å››å€‹æ ¼å­çš„ä¸­å¿ƒ
            scene.add(axesHelper);
        }
        
        function createBottomBars() {
            // Aè¡Œbaråƒæ•¸
            const barWidth = 16.6; // å¯¬åº¦ - é©æ‡‰8åˆ—ä½ˆå±€
            const barLength = 0.3; // é•·åº¦ï¼ˆè¦†è“‹A0-A7å…«å€‹boxesï¼‰
            const barHeight = 0.01; // åšåº¦
            
            // å‰µå»ºAè¡Œbarå¹¾ä½•é«”
            const barGeometry = new THREE.BoxGeometry(barWidth, barHeight, barLength);
            const barMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xff0000, // ç´…è‰²
                transparent: true,
                opacity: 1
            });
            
            // Aè¡Œbarä½ç½®ï¼ˆåœ¨Aè¡Œboxesåº•éƒ¨ï¼‰
            // Aè¡Œæ˜¯ç¬¬0è¡Œï¼Œä½ç½®åœ¨zè»¸æ­£æ–¹å‘
            const aBar = new THREE.Mesh(barGeometry, barMaterial);
            aBar.position.set(0, 0, -1.1); // æ°´å¹³å±…ä¸­ï¼Œåœ¨Aè¡Œboxesåº•éƒ¨
            scene.add(aBar);
            
            // Bè¡Œbaråƒæ•¸ï¼ˆè—è‰²ï¼‰
            const bBarMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0000ff, // è—è‰²
                transparent: true,
                opacity: 1
            });
            
            // Bè¡Œbarä½ç½®ï¼ˆåœ¨Bè¡Œboxesåº•éƒ¨ï¼‰
            const bBar = new THREE.Mesh(barGeometry, bBarMaterial);
            bBar.position.set(0, 0, 1.1); // æ°´å¹³å±…ä¸­ï¼Œåœ¨Bè¡Œboxesåº•éƒ¨
            scene.add(bBar);
        }
        
        function toggleInstructions() {
            const instructionsContent = document.getElementById('instructions-content');
            const toggleButton = document.querySelector('.instructions-toggle');
            
            if (instructionsContent.style.display === 'none') {
                // å±•é–‹
                instructionsContent.style.display = 'block';
                toggleButton.textContent = 'Introduction â–²';
            } else {
                // æ”¶èµ·
                instructionsContent.style.display = 'none';
                toggleButton.textContent = 'Introduction â–¼';
            }
        }

        function createBoxes() {
            const boxWidth = 2;
            const defaultBoxHeight = 0.4;
            const qBoxHeight = 0.9;
            const boxDepth = 2;
            const spacing = 0.2;
            
            // è¨ˆç®—ç¸½å¯¬åº¦å’Œç¸½æ·±åº¦ - ç¾åœ¨æ˜¯8åˆ—
            const totalWidth = 8 * boxWidth + 7 * spacing;
            const totalDepth = 2 * boxDepth + 1 * spacing;
            
            // è¨ˆç®—èµ·å§‹ä½ç½®ï¼Œä½¿boxeså±…ä¸­
            const startX = -totalWidth / 2 + boxWidth / 2;
            const startZ = -totalDepth / 2 + boxDepth / 2;
            
            // å‰µå»ºå…©è¡Œå…«åˆ—çš„boxes
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 8; col++) {
                    // æ±ºå®šé«˜åº¦
                    let boxHeight = (col === 0) ? qBoxHeight : defaultBoxHeight;
                    // å‰µå»ºboxå¹¾ä½•é«”
                    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
                    
                    // å‰µå»ºæè³ª - æ ¹æ“šæ˜¯å¦ç‚ºå›ºå®šboxè¨­ç½®ä¸åŒæè³ª
                    let material;
                    if (col === 0) {
                        // A0å’ŒB0ï¼šæ·ºè‰²åŠé€æ˜
                        material = new THREE.MeshLambertMaterial({
                            color: 0xcccccc, // æ·ºç°è‰²
                            transparent: true,
                            opacity: 0.85
                        });
                    } else if (col === 3 && row === 0) {
                        // A3ï¼šæ·¡ç´…è‰²
                        material = new THREE.MeshLambertMaterial({
                            color: 0xFA6D3E, // æ·¡ç´…è‰²
                            transparent: true,
                            opacity: 1
                        });
                    } else if (col === 4 && row === 0) {
                        // A4ï¼šæ¯”A3æ·¡ä¸€äº›çš„é¡è‰²
                        material = new THREE.MeshLambertMaterial({
                            color: 0xFFB366, // æ¯”A3æ·¡ä¸€äº›çš„æ©™è‰²
                            transparent: true,
                            opacity: 1
                        });
                    } else if (col === 7) {
                        // A7å’ŒB7ï¼šæ¯”A0æ·±ä¸€äº›çš„é¡è‰²
                        material = new THREE.MeshLambertMaterial({
                            color: 0xb8b8b8, // æ¯”A0æ·±ä¸€äº›çš„ç°è‰²
                            transparent: true,
                            opacity: 0.85
                        });
                    } else {
                        // å…¶ä»–boxesï¼šæ·±ç°è‰²ä¸é€æ˜
                        material = new THREE.MeshLambertMaterial({
                            color: 0x808080,
                            transparent: true,
                            opacity: 1
                        });
                    }
                    
                    // å‰µå»ºmesh
                    const box = new THREE.Mesh(geometry, material);
                    
                    // è¨ˆç®—ä½ç½®
                    const x = startX + col * (boxWidth + spacing);
                    const y = boxHeight / 2; // è®“boxåº•éƒ¨è²¼åœ°
                    const z = startZ + row * (boxDepth + spacing);
                    
                    box.position.set(x, y, z);
                    
                    // å‰µå»ºé‚Šç·šä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    box.add(wireframe); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // å‰µå»ºä½ç½®æ¨™ç±¤ï¼ˆå³ä¸Šè§’ï¼‰ä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    // const positionLabel = createLabel(row === 0 ? `A${col}` : `B${col}`);
                    // positionLabel.position.set(boxWidth/2 - 0.3, boxHeight/2 + 0.01, -boxDepth/2 + 0.3);
                    // box.add(positionLabel); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // å‰µå»ºç‹€æ…‹æ¨™ç±¤ï¼ˆé ‚é¢ä¸­å¤®ï¼‰ä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    let centerText = "I";
                    if (col === 0) {
                        // A0å’ŒB0ä½¿ç”¨Q1å’ŒQ2
                        centerText = row === 0 ? "Q1" : "Q2";
                    } else if (col === 3 && row === 0) {
                        // A3ä½¿ç”¨Ïƒxâ±
                        centerText = "Ïƒxâ±";
                    } else if (col === 4 && row === 0) {
                        // A4ä½¿ç”¨ÏƒzÊ²
                        centerText = "ÏƒzÊ²";
                    } else if (col === 7) {
                        // A7å’ŒB7ä½¿ç”¨M1å’ŒM2
                        centerText = row === 0 ? "M1" : "M2";
                    }
                    const stateLabel = createLabel(centerText);
                    stateLabel.position.set(0, boxHeight/2 + 0.02, 0);
                    stateLabel.rotation.x = -Math.PI / 2; // æ—‹è½‰90åº¦å¹³è²¼åœ¨é ‚é¢
                    box.add(stateLabel); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // æ·»åŠ ç”¨æˆ¶æ•¸æ“š
                    box.userData = { 
                        state: centerText, // ä½¿ç”¨å¯¦éš›é¡¯ç¤ºçš„æ–‡å­—ä½œç‚ºç‹€æ…‹
                        wireframe: wireframe,
                        // positionLabel: positionLabel, // å·²ç§»é™¤ä½ç½®æ¨™ç±¤
                        stateLabel: stateLabel,
                        isFixed: col === 0 || col === 7 || (col === 3 && row === 0) || (col === 4 && row === 0), // ç¬¬0åˆ—ã€ç¬¬7åˆ—ã€ç¬¬3åˆ—Aè¡Œå’Œç¬¬4åˆ—Aè¡Œï¼ˆA0ã€B0ã€A3ã€A4ã€A7ã€B7ï¼‰ç‚ºå›ºå®šä¸å¯äº’å‹•
                        boxHeight: boxHeight
                    };
                    
                    // åªæ·»åŠ boxåˆ°å ´æ™¯å’Œboxesæ•¸çµ„
                    scene.add(box);
                    boxes.push(box);
                }
            }
        }
        
        function createLabel(text) {
            // å‰µå»ºCanvasä¾†ç¹ªè£½æ–‡å­—
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            // æ¸…é™¤CanvasèƒŒæ™¯ï¼Œç¢ºä¿é€æ˜
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // åˆ¤æ–·æ˜¯å¦ç‚ºç‹€æ…‹æ¨™ç±¤ï¼ˆIã€Hã€â€¢ã€â¨ã€Q1ã€Q2ã€M1ã€M2ã€Ïƒxâ±æˆ–ÏƒzÊ²ï¼‰
            const isStateLabel = text === 'I' || text === 'H' || text === 'â€¢' || text === 'â¨' || text === 'Q1' || text === 'Q2' || text === 'M1' || text === 'M2' || text === 'Ïƒxâ±' || text === 'ÏƒzÊ²';
            
            // è¨­ç½®æ–‡å­—æ¨£å¼
            if (isStateLabel) {
                if (text === 'Q1' || text === 'Q2' || text === 'M1' || text === 'M2') {
                    // Q1ã€Q2ã€M1ã€M2ï¼šæ·±è‰²
                    context.fillStyle = '#333333'; // æ·±ç°è‰²
                } else if (text === 'Ïƒxâ±') {
                    // Ïƒxâ±ï¼šæ·±è‰²
                    context.fillStyle = '#333333'; //æ·ºç°è‰²
                } else if (text === 'ÏƒzÊ²') {
                    // ÏƒzÊ²ï¼šæ·±è‰²
                    context.fillStyle = '#333333'; //æ·ºç°è‰²
                } else {
                    // Iã€Hã€â€¢ã€â¨ï¼šæ·ºè‰²
                    context.fillStyle = '#E0E0E0'; // æ·ºç°è‰²
                }
                context.font = 'bold 180px Georgia';
            } else {
                // ä½ç½®æ¨™ç±¤ï¼šæ ¹æ“šå…§å®¹è¨­ç½®é¡è‰²
                if (text === 'X1' || text === 'Z1') {
                    context.fillStyle = '#ff0000'; // ç´…è‰²ï¼Œèˆ‡ç´…è‰²barä¸€è‡´
                } else if (text === 'X2' || text === 'Z2') {
                    context.fillStyle = '#0000ff'; // è—è‰²ï¼Œèˆ‡è—è‰²barä¸€è‡´
                } else {
                    context.fillStyle = '#000000'; // å…¶ä»–ä½ç½®æ¨™ç±¤ä¿æŒé»‘è‰²
                }
                context.font = 'bold 100px Arial';
            }
            
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // ç¹ªè£½æ–‡å­—
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // å‰µå»ºæè³ª - å•Ÿç”¨é€æ˜é€šé“
            const texture = new THREE.CanvasTexture(canvas);
            texture.premultiplyAlpha = false;
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1, // è¨­ç½®alphaæ¸¬è©¦é–¾å€¼
                side: THREE.DoubleSide
            });
            
            // å‰µå»ºå¹³é¢å¹¾ä½•é«”ä½œç‚ºæ¨™ç±¤
            const geometry = new THREE.PlaneGeometry(0.8, 0.8);
            const label = new THREE.Mesh(geometry, material);
            
            // è®“æ¨™ç±¤æœå‘Yæ–¹å‘ï¼ˆå‚ç›´å‘ä¸Šï¼‰
            label.rotation.x = -Math.PI / 2; // æ—‹è½‰90åº¦ï¼Œè®“æ¨™ç±¤å‚ç›´å‘ä¸Š
            
            return label;
        }
        

        
        function animate() {
            animationId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function initInteraction() {
            // åˆå§‹åŒ–å°„ç·šæª¢æ¸¬å™¨å’Œæ»‘é¼ 
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
            const canvas = document.getElementById('game-canvas');
            canvas.addEventListener('click', onMouseClick);
        }
        
        function onMouseClick(event) {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // è¨ˆç®—æ»‘é¼ åœ¨ç•«å¸ƒä¸­çš„æ¨™æº–åŒ–åº§æ¨™
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // æ›´æ–°å°„ç·š
            raycaster.setFromCamera(mouse, camera);
            
            // æª¢æ¸¬èˆ‡ boxes çš„ç›¸äº¤
            const intersects = raycaster.intersectObjects(boxes);
            
            if (intersects.length > 0) {
                const clickedBox = intersects[0].object;
                // æª¢æŸ¥æ˜¯å¦ç‚ºå›ºå®šboxï¼Œå¦‚æœæ˜¯å‰‡ä¸åŸ·è¡Œé»æ“Šæ•ˆæœ
                if (!clickedBox.userData.isFixed) {
                    changeBoxColor(clickedBox);
                }
            }
        }
        
        function changeBoxColor(box) {
            // æª¢æŸ¥ç•¶å‰ç‹€æ…‹ä¸¦æŒ‰ç…§ I â†’ H â†’ â€¢ â†’ â¨ çš„é †åºå¾ªç’°
            if (box.userData.state === "I") {
                // å¾ "I" è®Šæˆ "H"
                box.userData.state = "H";
                box.material.color.setHex(0x3498db); // è—è‰²
                updateStateLabel(box, "H");
            } else if (box.userData.state === "H") {
                // å¾ "H" è®Šæˆ "â€¢"
                box.userData.state = "â€¢";
                box.material.color.setHex(0x808080); // ç°è‰²ï¼Œèˆ‡Iç›¸åŒ
                updateStateLabel(box, "â€¢");
            } else if (box.userData.state === "â€¢") {
                // å¾ "â€¢" è®Šæˆ "â¨"
                box.userData.state = "â¨";
                box.material.color.setHex(0x808080); // ç°è‰²ï¼Œèˆ‡Iç›¸åŒ
                updateStateLabel(box, "â¨");
            } else {
                // å¾ "â¨" è®Šå› "I"
                box.userData.state = "I";
                box.material.color.setHex(0x808080); // ç°è‰²
                updateStateLabel(box, "I");
            }
            
            // è§¸ç™¼æœå‡æŠ–å‹•ç‰¹æ•ˆ
            triggerJellyEffect(box);
            
            // æª¢æŸ¥CNOT gateè¦å‰‡ä¸¦æ›´æ–°é¡è‰²
            checkAndUpdateCNOTColors();
        }
        
        function updateStateLabel(box, text) {
            // ç§»é™¤èˆŠçš„ç‹€æ…‹æ¨™ç±¤
            box.remove(box.userData.stateLabel);
            
            // å‰µå»ºæ–°çš„ç‹€æ…‹æ¨™ç±¤
            const newStateLabel = createLabel(text);
            newStateLabel.position.copy(box.userData.stateLabel.position);
            newStateLabel.rotation.copy(box.userData.stateLabel.rotation);
            
            // æ›´æ–°ç”¨æˆ¶æ•¸æ“š
            box.userData.stateLabel = newStateLabel;
            
            // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
            box.add(newStateLabel);
        }
        
        function triggerJellyEffect(box) {
            // ä¿å­˜åŸå§‹ä½ç½®
            const originalY = box.position.y;
            
            // æŠ–å‹•åƒæ•¸
            const duration = 700; // 0.7ç§’
            const amplitude = 0.15; // æŠ–å‹•å¹…åº¦
            const frequency = 9; // æŠ–å‹•é »ç‡
            const startTime = Date.now();
            
            function jellyAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    // ä½¿ç”¨è¡°æ¸›çš„æ­£å¼¦æ³¢å‰µå»ºæœå‡æ•ˆæœ
                    const decay = Math.exp(-progress * 3); // è¡°æ¸›å› å­
                    const oscillation = Math.sin(progress * frequency * Math.PI) * decay;
                    
                    // åªæœ‰ä¸Šä¸‹æŠ–å‹•ï¼Œä¸æ”¹è®Šå¤§å°
                    box.position.y = originalY + oscillation * amplitude;
                    
                    requestAnimationFrame(jellyAnimation);
                } else {
                    // æ¢å¾©åŸå§‹ä½ç½®
                    box.position.y = originalY;
                }
            }
            
            jellyAnimation();
        }
        
        // Q1/Q2æè¿°å­ç‹€æ…‹
        let q1Left = 'X1', q1Right = 'Z1';
        let q2Left = 'X2', q2Right = 'Z2';
        
        // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
        function updateTimeStepDisplay() {
            const timeStepDisplay = document.getElementById('time-step-display');
            if (timeStepDisplay) {
                timeStepDisplay.textContent = `t = ${t}`;
            }
        }

        // Run æŒ‰éˆ•åŠŸèƒ½
        function runSimulation() {
            console.log('Simulation started!');
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
            if (checkInvalidCNOTGates()) {
                console.log('Invalid CNOT gate detected! Showing error...');
                showErrorEffect();
                return; // é˜»æ­¢æ¨¡æ“¬é‹è¡Œ
            }
            
            if (t >= 7) {
                console.log('Simulation completed, cannot run further');
                return;
            }
            
            t++;
            updateTimeStepDisplay(); // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
            addGlowEffectToColumn(t);

            // CNOT descriptor é‹ç®—
            executeCNOTLogicForColumn(t);

            // æª¢æŸ¥Aè¡Œ/Bè¡Œç•¶å‰tåˆ—boxç‹€æ…‹
            const aBox = boxes[t]; // row=0, col=t
            const bBox = boxes[8 + t]; // row=1, col=t
            
            // è™•ç†Aè¡Œboxç‹€æ…‹
            if (aBox.userData.state === 'H') {
                // Q1å·¦å³äº’æ›
                [q1Left, q1Right] = [q1Right, q1Left];
            } else if (aBox.userData.state === 'Ïƒxâ±') {
                // Ïƒxâ±é‚è¼¯ï¼šQ1 = (left, (-1)^i right)
                // éš¨æ©Ÿç”Ÿæˆiå€¼ï¼ˆ0æˆ–1ï¼‰
                randomI = Math.random() < 0.5 ? 0 : 1;
                console.log(`Ïƒxâ±ç™¼å…‰ï¼Œéš¨æ©Ÿç”Ÿæˆ i = ${randomI}`);
                if (q1Right.startsWith('X')) {
                    q1Right = '(-1)^(i)X' + q1Right.substring(1);
                } else if (q1Right.startsWith('Z')) {
                    q1Right = '(-1)^(i)Z' + q1Right.substring(1);
                }
            } else if (aBox.userData.state === 'ÏƒzÊ²') {
                // ÏƒzÊ²é‚è¼¯ï¼šQ1 = ((-1)^j left, right)
                // éš¨æ©Ÿç”Ÿæˆjå€¼ï¼ˆ0æˆ–1ï¼‰
                randomJ = Math.random() < 0.5 ? 0 : 1;
                console.log(`ÏƒzÊ²ç™¼å…‰ï¼Œéš¨æ©Ÿç”Ÿæˆ j = ${randomJ}`);
                if (q1Left.startsWith('X')) {
                    q1Left = '(-1)^(j)X' + q1Left.substring(1);
                } else if (q1Left.startsWith('Z')) {
                    q1Left = '(-1)^(j)Z' + q1Left.substring(1);
                }
            }
            
            // è™•ç†Bè¡Œboxç‹€æ…‹
            if (bBox.userData.state === 'H') {
                // Q2å·¦å³äº’æ›
                [q2Left, q2Right] = [q2Right, q2Left];
            } else if (bBox.userData.state === 'Ïƒxâ±') {
                // Ïƒxâ±é‚è¼¯ï¼šQ2 = (left, (-1)^i right)
                // ä½¿ç”¨å·²ç”Ÿæˆçš„iå€¼
                if (q2Right.startsWith('X')) {
                    q2Right = '(-1)^(i)X' + q2Right.substring(1);
                } else if (q2Right.startsWith('Z')) {
                    q2Right = '(-1)^(i)Z' + q2Right.substring(1);
                }
            } else if (bBox.userData.state === 'ÏƒzÊ²') {
                // ÏƒzÊ²é‚è¼¯ï¼šQ2 = ((-1)^j left, right)
                // ä½¿ç”¨å·²ç”Ÿæˆçš„jå€¼
                if (q2Left.startsWith('X')) {
                    q2Left = '(-1)^(j)X' + q2Left.substring(1);
                } else if (q2Left.startsWith('Z')) {
                    q2Left = '(-1)^(j)Z' + q2Left.substring(1);
                }
            }
            updateDescriptor();

            if (t >= 7) {
                const runButton = document.querySelector('.run-button');
                runButton.disabled = true;
                runButton.style.background = '#cccccc';
                runButton.style.cursor = 'not-allowed';
            }
            console.log(`Time step: t = ${t}`);
        }

        // æ›´æ–°monitorå…§çš„descriptoré¡¯ç¤º
        function updateDescriptor() {
            const q1Elem = document.querySelector('.descriptor-panel .monitor-block:nth-child(1) .content p');
            const q2Elem = document.querySelector('.descriptor-panel .monitor-block:nth-child(2) .content p');
            
            if (q1Elem) {
                let html = `Q1 = (<span>${q1Left}</span>,<span>${q1Right}</span>)`;
                html = html.replace(/X1|Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/X2|Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(i\)X1|\(-1\)\^\(i\)Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(i\)X2|\(-1\)\^\(i\)Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(j\)X1|\(-1\)\^\(j\)Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(j\)X2|\(-1\)\^\(j\)Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>');
                q1Elem.innerHTML = html;
            }
            if (q2Elem) {
                let html = `Q2 = (<span>${q2Left}</span>,<span>${q2Right}</span>)`;
                html = html.replace(/X1|Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/X2|Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(i\)X1|\(-1\)\^\(i\)Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(i\)X2|\(-1\)\^\(i\)Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(j\)X1|\(-1\)\^\(j\)Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/\(-1\)\^\(j\)X2|\(-1\)\^\(j\)Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>');
                q2Elem.innerHTML = html;
            }
            
            // æ›´æ–°Pass Hintss
            updateExpectationValues();
        }
        
        // æ›´æ–°Pass Hintss
        function updateExpectationValues() {
            // æª¢æŸ¥M1å’ŒM2æ˜¯å¦ç™¼å…‰ï¼ˆt=7æ™‚ï¼‰
            if (t < 7) {
                // å¦‚æœé‚„æ²’åˆ°M1M2ç™¼å…‰çš„æ™‚å€™ï¼Œé¡¯ç¤ºç­‰å¾…ç‹€æ…‹
                const q1ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(1) .content p');
                const q2ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(2) .content p');
                
                if (q1ExpectElem) {
                    q1ExpectElem.textContent = `Exc.X(Q1) = ?,    Exc.Z(Q1) = ?`;
                }
                if (q2ExpectElem) {
                    q2ExpectElem.textContent = `Exc.X(Q2) = ?,    Exc.Z(Q2) = ?`;
                }
                return;
            }
            
            // åªæœ‰åœ¨M1M2ç™¼å…‰æ™‚æ‰è¨ˆç®—Pass Hintss
            // è¨ˆç®—Q1çš„Pass Hintss
            let excXQ1 = q1Left.includes('X') ? 0 : 1;
            let excZQ1 = q1Right.includes('X') ? 0 : 1;
            
            // è™•ç†(-1)^(i)å’Œ(-1)^(j)æ ¼å¼ï¼Œä½¿ç”¨å¯¦éš›çš„iå’Œjå€¼
            if (q1Left.startsWith('(-1)^(i)')) {
                excXQ1 = Math.pow(-1, randomI) * excXQ1;
            } else if (q1Left.startsWith('(-1)^(j)')) {
                excXQ1 = Math.pow(-1, randomJ) * excXQ1;
            }
            
            if (q1Right.startsWith('(-1)^(i)')) {
                excZQ1 = Math.pow(-1, randomI) * excZQ1;
            } else if (q1Right.startsWith('(-1)^(j)')) {
                excZQ1 = Math.pow(-1, randomJ) * excZQ1;
            }
            
            // è¨ˆç®—Q2çš„Pass Hintss
            let excXQ2 = q2Left.includes('X') ? 0 : 1;
            let excZQ2 = q2Right.includes('X') ? 0 : 1;
            
            // è™•ç†(-1)^(i)å’Œ(-1)^(j)æ ¼å¼ï¼Œä½¿ç”¨å¯¦éš›çš„iå’Œjå€¼
            if (q2Left.startsWith('(-1)^(i)')) {
                excXQ2 = Math.pow(-1, randomI) * excXQ2;
            } else if (q2Left.startsWith('(-1)^(j)')) {
                excXQ2 = Math.pow(-1, randomJ) * excXQ2;
            }
            
            if (q2Right.startsWith('(-1)^(i)')) {
                excZQ2 = Math.pow(-1, randomI) * excZQ2;
            } else if (q2Right.startsWith('(-1)^(j)')) {
                excZQ2 = Math.pow(-1, randomJ) * excZQ2;
            }
            
            // æ›´æ–°é¡¯ç¤º
            const q1ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(1) .content p');
            const q2ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(2) .content p');
            
            if (q1ExpectElem) {
                q1ExpectElem.innerHTML = `Exc.X(Q1) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excXQ1}</span></strong>,    Exc.Z(Q1) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excZQ1}</span></strong>`;
            }
            if (q2ExpectElem) {
                q2ExpectElem.innerHTML = `Exc.X(Q2) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excXQ2}</span></strong>,    Exc.Z(Q2) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excZQ2}</span></strong>`;
            }
        }

        // ç‚ºæŒ‡å®šåˆ—çš„boxesæ·»åŠ ç™¼å…‰æ•ˆæœ
        function addGlowEffectToColumn(columnIndex) {
            boxes.forEach((box, index) => {
                const row = Math.floor(index / 8); // 0æˆ–1
                const col = index % 8; // 0, 1, 2, 3, 4, 5, 6, 7
                
                if (col === columnIndex) {
                    // ç‚ºè©²åˆ—çš„boxesæ·»åŠ ç™¼å…‰æ•ˆæœ
                    addGlowEffect(box);
                }
            });
        }
        
        // ç‚ºå–®å€‹boxæ·»åŠ ç™¼å…‰æ•ˆæœ
        function addGlowEffect(box) {
            // ä¿å­˜åŸå§‹æè³ª
            const originalMaterial = box.material;
            
            // å‰µå»ºç™¼å…‰æè³ª
            const glowMaterial = originalMaterial.clone();
            
            // æ ¹æ“šboxçš„ç‹€æ…‹è¨­ç½®ç™¼å…‰é¡è‰²
            if (box.userData.state === 'Ïƒxâ±') {
                // Ïƒxâ±ä½¿ç”¨ç‰¹æ®Šçš„ç™¼å…‰é¡è‰²
                glowMaterial.emissive = new THREE.Color(0xFF6026); // äº®ç´…è‰²ç™¼å…‰
                glowMaterial.emissiveIntensity = 0.6; // è¼ƒå¼·çš„ç™¼å…‰å¼·åº¦
            } else if (box.userData.state === 'ÏƒzÊ²') {
                // ÏƒzÊ²ä½¿ç”¨ç‰¹æ®Šçš„ç™¼å…‰é¡è‰²
                glowMaterial.emissive = new THREE.Color(0xFFB366); // äº®æ©™è‰²ç™¼å…‰
                glowMaterial.emissiveIntensity = 0.6; // è¼ƒå¼·çš„ç™¼å…‰å¼·åº¦
            } else {
                // å…¶ä»–boxesä½¿ç”¨èˆ‡boxç›¸åŒçš„é¡è‰²
                const originalColor = originalMaterial.color;
                glowMaterial.emissive = originalColor.clone();
                glowMaterial.emissiveIntensity = 0.4; // é©ä¸­çš„ç™¼å…‰å¼·åº¦
            }
            
            // æ‡‰ç”¨ç™¼å…‰æè³ª
            box.material = glowMaterial;
            
            // ä¿å­˜åŸå§‹æè³ªä»¥ä¾¿å¾ŒçºŒæ¢å¾©
            box.userData.originalMaterial = originalMaterial;
            
            // æ·»åŠ é«˜åº¦å¢é«˜æ•ˆæœ
            addHeightEffect(box);
        }
        
        // ç‚ºboxæ·»åŠ é«˜åº¦å¢é«˜æ•ˆæœ
        function addHeightEffect(box) {
            // ä¿å­˜åŸå§‹Yä½ç½®
            const originalY = box.position.y;
            const targetY = originalY + 0.5; // å¢é«˜0.2
            
            // å‹•ç•«åƒæ•¸
            const duration = 500; // 0.5ç§’
            const startTime = Date.now();
            
            function heightAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    // ä½¿ç”¨ç·©å‹•å‡½æ•¸è®“å‹•ç•«æ›´è‡ªç„¶
                    const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic
                    
                    // è¨ˆç®—æ–°çš„Yä½ç½®
                    const newY = originalY + (targetY - originalY) * easeProgress;
                    box.position.y = newY;
                    
                    requestAnimationFrame(heightAnimation);
                } else {
                    // å‹•ç•«çµæŸï¼Œè¨­ç½®åˆ°ç›®æ¨™ä½ç½®
                    box.position.y = targetY;
                }
            }
            
            heightAnimation();
        }
        
        // æ¸…é™¤æ‰€æœ‰boxesçš„ç™¼å…‰æ•ˆæœ
        function clearAllGlowEffects() {
            boxes.forEach(box => {
                if (box.userData.originalMaterial) {
                    box.material = box.userData.originalMaterial;
                    delete box.userData.originalMaterial;
                }
            });
        }
        
        // Reset åŠŸèƒ½
        function resetSimulation() {
            console.log('Simulation reset!');
            t = 0;
            updateTimeStepDisplay(); // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
            clearAllGlowEffects();
            // é‡ç½®Q1/Q2æè¿°å­
            q1Left = 'X1'; q1Right = 'Z1';
            q2Left = 'X2'; q2Right = 'Z2';
            
            // é‡ç½®éš¨æ©Ÿiå’Œjå€¼
            randomI = 0;
            randomJ = 0;
            
            // é‡ç½®classical bits
            bitI = '?';
            bitJ = '?';
            document.getElementById('bit-i').textContent = 'i = ?';
            document.getElementById('bit-j').textContent = 'j = ?';
            
            // é‡ç½®æ­å–œç‰¹æ•ˆè§¸ç™¼ç‹€æ…‹
            hasTriggeredCelebration = false;
            hasCheckedAfterM1M2 = false;
            hasCheckedOnce = false;
            // æ³¨æ„ï¼šä¸é‡ç½®successCountï¼Œè®“æˆåŠŸæ¬¡æ•¸æŒçºŒç´¯ç©
            
            // é‡ç½®classical bit blocksçš„æ¨£å¼
            const bitIBlock = document.querySelector('.classical-bit-block:nth-child(1)');
            const bitJBlock = document.querySelector('.classical-bit-block:nth-child(2)');
            if (bitIBlock) {
                bitIBlock.style.background = 'rgba(255, 255, 255, 0.9)';
                bitIBlock.style.borderColor = '#2f4f78';
                bitIBlock.style.boxShadow = 'none';
            }
            if (bitJBlock) {
                bitJBlock.style.background = 'rgba(255, 255, 255, 0.9)';
                bitJBlock.style.borderColor = '#2f4f78';
                bitJBlock.style.boxShadow = 'none';
            }
            
            updateDescriptor();
            boxes.forEach((box, idx) => {
                const currentState = box.userData.state;
                const isFixed = box.userData.isFixed;
                const col = idx % 8;
                if (col !== 0) {
                    box.position.y = box.userData.boxHeight / 2;
                }
                box.userData.state = currentState;
                box.userData.isFixed = isFixed;
            });
            const runButton = document.querySelector('.run-button');
            runButton.disabled = false;
            runButton.style.background = '#4CAF50';
            runButton.style.cursor = 'pointer';
            console.log('Simulation reset to t = 0');
        }
        
        // æª¢æŸ¥ä¸¦æ›´æ–°CNOT gateé¡è‰²
        function checkAndUpdateCNOTColors() {
            // å®šç¾©8åˆ—çš„ä½ˆå±€
            // ç¬¬0åˆ—ï¼šboxes[0], boxes[8] (A0, B0) - å›ºå®šboxes
            // ç¬¬1åˆ—ï¼šboxes[1], boxes[9] (A1, B1) - å¯äº’å‹•boxes
            // ç¬¬2åˆ—ï¼šboxes[2], boxes[10] (A2, B2) - å¯äº’å‹•boxes
            // ç¬¬3åˆ—ï¼šboxes[3], boxes[11] (A3, B3) - å¯äº’å‹•boxes
            // ç¬¬4åˆ—ï¼šboxes[4], boxes[12] (A4, B4) - å¯äº’å‹•boxes
            // ç¬¬5åˆ—ï¼šboxes[5], boxes[13] (A5, B5) - å¯äº’å‹•boxes
            // ç¬¬6åˆ—ï¼šboxes[6], boxes[14] (A6, B6) - å¯äº’å‹•boxes
            // ç¬¬7åˆ—ï¼šboxes[7], boxes[15] (A7, B7) - å›ºå®šboxes
            
            const column0 = [boxes[0], boxes[8]]; // ç¬¬0åˆ—
            const column1 = [boxes[1], boxes[9]]; // ç¬¬1åˆ—
            const column2 = [boxes[2], boxes[10]]; // ç¬¬2åˆ—
            const column3 = [boxes[3], boxes[11]]; // ç¬¬3åˆ—
            const column4 = [boxes[4], boxes[12]]; // ç¬¬4åˆ—
            const column5 = [boxes[5], boxes[13]]; // ç¬¬5åˆ—
            const column6 = [boxes[6], boxes[14]]; // ç¬¬6åˆ—
            const column7 = [boxes[7], boxes[15]]; // ç¬¬7åˆ—
            
            // æª¢æŸ¥æ¯ä¸€åˆ—
            checkColumnForCNOT(column0);
            checkColumnForCNOT(column1);
            checkColumnForCNOT(column2);
            checkColumnForCNOT(column3);
            checkColumnForCNOT(column4);
            checkColumnForCNOT(column5);
            checkColumnForCNOT(column6);
            checkColumnForCNOT(column7);
        }
        
        // --- CNOT descriptor é‹ç®—èˆ‡æŠµéŠ· ---
        function cancelIdenticalOperators(expression) {
            if (!expression || expression === '1') return '1';
            
            // åŒ¹é…æ‰€æœ‰operatorsï¼ŒåŒ…æ‹¬(-1)^(i)ã€(-1)^(j)ã€X1ã€X2ã€Z1ã€Z2
            const operators = expression.match(/(\(-1\)\^\([ij]\)|X\d|Z\d)/g) || [];
            if (operators.length === 0) return '1';
            
            const operatorCount = {};
            operators.forEach(op => {
                operatorCount[op] = (operatorCount[op] || 0) + 1;
            });
            
            const remainingOperators = [];
            Object.keys(operatorCount).forEach(op => {
                // åªå°X1ã€X2ã€Z1ã€Z2é€²è¡ŒæŠµéŠ·é‚è¼¯
                if (op.match(/^X\d$|^Z\d$/)) {
                    if (operatorCount[op] % 2 === 1) {
                        remainingOperators.push(op);
                    }
                } else {
                    // å°æ–¼(-1)^(i)å’Œ(-1)^(j)ï¼Œç›´æ¥ä¿ç•™
                    remainingOperators.push(op);
                }
            });
            
            if (remainingOperators.length === 0) return '1';
            return remainingOperators.join('');
        }

        function executeCNOTLogicForColumn(colIdx) {
            // å–å¾—è©²åˆ—çš„å…©å€‹box
            const aBox = boxes[colIdx];
            const bBox = boxes[8 + colIdx];
            // åªæœ‰åŒæ™‚å­˜åœ¨ä¸”ç‚ºåœŸé»ƒè‰²æ‰åŸ·è¡Œ
            if (!((aBox.userData.state === 'â€¢' && bBox.userData.state === 'â¨') || (aBox.userData.state === 'â¨' && bBox.userData.state === 'â€¢'))) return;
            if (!(aBox.material.color.getHex() === 0xd4af37 && bBox.material.color.getHex() === 0xd4af37)) return;
            // å–å¾— Q1/Q2 ç•¶å‰æè¿°å­
            let q1L = q1Left, q1R = q1Right, q2L = q2Left, q2R = q2Right;
            // æ±ºå®šèª°æ˜¯ dot èª°æ˜¯ xor
            let dotIsQ1 = (aBox.userData.state === 'â€¢');
            let newQ1Left, newQ1Right, newQ2Left, newQ2Right;
            if (dotIsQ1) {
                // Q1: â€¢, Q2: â¨
                newQ1Left = q1L + q2L;
                newQ1Right = q1R;
                newQ2Left = q2L;
                newQ2Right = q1R + q2R;
            } else {
                // Q2: â€¢, Q1: â¨
                newQ2Left = q2L + q1L;
                newQ2Right = q2R;
                newQ1Left = q1L;
                newQ1Right = q2R + q1R;
            }
            // æŠµéŠ·
            q1Left = cancelIdenticalOperators(newQ1Left);
            q1Right = cancelIdenticalOperators(newQ1Right);
            q2Left = cancelIdenticalOperators(newQ2Left);
            q2Right = cancelIdenticalOperators(newQ2Right);
            updateDescriptor();
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
        function checkInvalidCNOTGates() {
            // å®šç¾©8åˆ—çš„ä½ˆå±€
            const column0 = [boxes[0], boxes[8]]; // ç¬¬0åˆ—
            const column1 = [boxes[1], boxes[9]]; // ç¬¬1åˆ—
            const column2 = [boxes[2], boxes[10]]; // ç¬¬2åˆ—
            const column3 = [boxes[3], boxes[11]]; // ç¬¬3åˆ—
            const column4 = [boxes[4], boxes[12]]; // ç¬¬4åˆ—
            const column5 = [boxes[5], boxes[13]]; // ç¬¬5åˆ—
            const column6 = [boxes[6], boxes[14]]; // ç¬¬6åˆ—
            const column7 = [boxes[7], boxes[15]]; // ç¬¬7åˆ—
            
            // æª¢æŸ¥æ¯ä¸€åˆ—æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
            const column0Invalid = checkColumnForCNOT(column0);
            const column1Invalid = checkColumnForCNOT(column1);
            const column2Invalid = checkColumnForCNOT(column2);
            const column3Invalid = checkColumnForCNOT(column3);
            const column4Invalid = checkColumnForCNOT(column4);
            const column5Invalid = checkColumnForCNOT(column5);
            const column6Invalid = checkColumnForCNOT(column6);
            const column7Invalid = checkColumnForCNOT(column7);
            
            return column0Invalid || column1Invalid || column2Invalid || column3Invalid || column4Invalid || column5Invalid || column6Invalid || column7Invalid;
        }
        
        function checkColumnForCNOT(columnBoxes) {
            let hasDot = false;
            let hasXOR = false;
            let dotBox = null;
            let xorBox = null;
            
            // æª¢æŸ¥é€™ä¸€åˆ—æ˜¯å¦æœ‰"â€¢"å’Œ"â¨"
            for (let box of columnBoxes) {
                if (box.userData.state === "â€¢") {
                    hasDot = true;
                    dotBox = box;
                } else if (box.userData.state === "â¨") {
                    hasXOR = true;
                    xorBox = box;
                }
            }
            
            // å¦‚æœåŒæ™‚å­˜åœ¨"â€¢"å’Œ"â¨"ï¼Œå°‡å®ƒå€‘è®Šæˆé»ƒè‰²
            if (hasDot && hasXOR) {
                console.log("CNOT gate detected! Changing â€¢ and â¨ to yellow");
                
                // å°‡"â€¢"è®ŠæˆåœŸé»ƒè‰²
                dotBox.material.color.setHex(0xd4af37); // åœŸé»ƒè‰²
                
                // å°‡"â¨"è®ŠæˆåœŸé»ƒè‰²
                xorBox.material.color.setHex(0xd4af37); // åœŸé»ƒè‰²
                
            } else {
                // å¦‚æœæ²’æœ‰åŒæ™‚å­˜åœ¨ï¼Œé¡¯ç¤ºç‚ºæ·¡é»ƒè‰²
                for (let box of columnBoxes) {
                    if (box.userData.state === "â€¢" || box.userData.state === "â¨") {
                        box.material.color.setHex(0xb8b89a); // æ·¡é»ƒç°è‰²ï¼Œèˆ‡Iç›¸è¿‘
                    }
                }
            }
            
            // è¿”å›æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gateï¼ˆåªæœ‰ä¸€å€‹"â€¢"æˆ–"â¨"ï¼‰
            return (hasDot && !hasXOR) || (!hasDot && hasXOR);
        }
        
        // é¡¯ç¤ºerroræ•ˆæœ
        function showErrorEffect() {
            const runButton = document.querySelector('.run-button');
            const originalBackground = runButton.style.background;
            const originalText = runButton.textContent;
            
            // æ”¹è®ŠæŒ‰éˆ•é¡è‰²å’Œæ–‡å­—
            runButton.style.background = '#ff0000'; // ç´…è‰²
            runButton.textContent = 'ERROR';
            
            // 0.3ç§’å¾Œæ¢å¾©
            setTimeout(() => {
                runButton.style.background = originalBackground;
                runButton.textContent = originalText;
            }, 300);
        }
        
        // Classical bits è®Šé‡
        let bitI = '?';
        let bitJ = '?';
        
        // éš¨æ©Ÿç”Ÿæˆçš„iå’Œjå€¼ï¼ˆç”¨æ–¼Ïƒxâ±å’ŒÏƒzÊ²é‹ç®—ï¼‰
        let randomI = 0;
        let randomJ = 0;
        
        // æ­å–œç‰¹æ•ˆè§¸ç™¼æ§åˆ¶
        let hasTriggeredCelebration = false;
        let hasCheckedAfterM1M2 = false; // è¿½è¹¤æ˜¯å¦åœ¨M1M2ç™¼å…‰å¾Œå·²ç¶“é»æ“ŠéCheck
        let hasCheckedOnce = false; // è¿½è¹¤æ˜¯å¦å·²ç¶“é»æ“ŠéCheckï¼ˆé˜²æ­¢é‡è¤‡é»æ“Šï¼‰
        let successCount = 0; // ç´¯ç©æˆåŠŸæ¬¡æ•¸
        
        // åˆ‡æ›bitå€¼çš„å‡½æ•¸
        function toggleBit(bitType) {
            if (bitType === 'i') {
                if (bitI === '?') {
                    bitI = '0';
                } else if (bitI === '0') {
                    bitI = '1';
                } else {
                    bitI = '0';
                }
                document.getElementById('bit-i').textContent = `i = ${bitI}`;
            } else if (bitType === 'j') {
                if (bitJ === '?') {
                    bitJ = '0';
                } else if (bitJ === '0') {
                    bitJ = '1';
                } else {
                    bitJ = '0';
                }
                document.getElementById('bit-j').textContent = `j = ${bitJ}`;
            }
        }
        
        // CheckæŒ‰éˆ•åŠŸèƒ½
        function checkAnswer() {
            // å¦‚æœå·²ç¶“é»æ“ŠéCheckï¼Œç›´æ¥è¿”å›
            if (hasCheckedOnce) {
                return;
            }
            
            console.log('Check button clicked!');
            console.log(`Current values: i = ${bitI}, j = ${bitJ}`);
            console.log(`Hidden values: randomI = ${randomI}, randomJ = ${randomJ}`);
            
            // æ¨™è¨˜å·²ç¶“é»æ“ŠéCheck
            hasCheckedOnce = true;
            
            // ç²å–classical bit blocks
            const bitIBlock = document.querySelector('.classical-bit-block:nth-child(1)');
            const bitJBlock = document.querySelector('.classical-bit-block:nth-child(2)');
            
            // æª¢æŸ¥æ˜¯å¦æœ‰æœªè¨­ç½®çš„classical bits
            if (bitI === '?' || bitJ === '?') {
                showUnsetBitsModal();
                return;
            }
            
            let iCorrect = false, jCorrect = false;
            // æª¢æŸ¥iå€¼
            iCorrect = parseInt(bitI) === randomI;
            if (iCorrect) {
                bitIBlock.style.borderColor = '#4CAF50';
                bitIBlock.style.borderWidth = '3px';
                bitIBlock.style.boxShadow = '0 0 15px rgba(76, 175, 80, 0.8), inset 0 0 5px rgba(76, 175, 80, 0.2)';
                setTimeout(() => {
                    bitIBlock.style.borderColor = '#2f4f78';
                    bitIBlock.style.borderWidth = '2px';
                    bitIBlock.style.boxShadow = 'none';
                }, 200);
            } else {
                let flashCount = 0;
                function flashRed() {
                    if (flashCount >= 4) {
                        bitIBlock.style.borderColor = '#2f4f78';
                        bitIBlock.style.borderWidth = '2px';
                        bitIBlock.style.boxShadow = 'none';
                        return;
                    }
                    if (flashCount % 2 === 0) {
                        bitIBlock.style.borderColor = '#f44336';
                        bitIBlock.style.borderWidth = '3px';
                        bitIBlock.style.boxShadow = '0 0 15px rgba(244, 67, 54, 0.8), inset 0 0 5px rgba(244, 67, 54, 0.2)';
                    } else {
                        bitIBlock.style.borderColor = '#2f4f78';
                        bitIBlock.style.borderWidth = '2px';
                        bitIBlock.style.boxShadow = 'none';
                    }
                    flashCount++;
                    setTimeout(flashRed, 200);
                }
                flashRed();
            }
            
            // æª¢æŸ¥jå€¼
            jCorrect = parseInt(bitJ) === randomJ;
            if (jCorrect) {
                bitJBlock.style.borderColor = '#4CAF50';
                bitJBlock.style.borderWidth = '3px';
                bitJBlock.style.boxShadow = '0 0 15px rgba(76, 175, 80, 0.8), inset 0 0 5px rgba(76, 175, 80, 0.2)';
                setTimeout(() => {
                    bitJBlock.style.borderColor = '#2f4f78';
                    bitJBlock.style.borderWidth = '2px';
                    bitJBlock.style.boxShadow = 'none';
                }, 200);
            } else {
                let flashCount = 0;
                function flashRedJ() {
                    if (flashCount >= 4) {
                        bitJBlock.style.borderColor = '#2f4f78';
                        bitJBlock.style.borderWidth = '2px';
                        bitJBlock.style.boxShadow = 'none';
                        return;
                    }
                    if (flashCount % 2 === 0) {
                        bitJBlock.style.borderColor = '#f44336';
                        bitJBlock.style.borderWidth = '3px';
                        bitJBlock.style.boxShadow = '0 0 15px rgba(244, 67, 54, 0.8), inset 0 0 5px rgba(244, 67, 54, 0.2)';
                    } else {
                        bitJBlock.style.borderColor = '#2f4f78';
                        bitJBlock.style.borderWidth = '2px';
                        bitJBlock.style.boxShadow = 'none';
                    }
                    flashCount++;
                    setTimeout(flashRedJ, 200);
                }
                flashRedJ();
            }
            
            // æª¢æŸ¥æ˜¯å¦åœ¨M1M2ç™¼å…‰å¾Œç¬¬ä¸€æ¬¡é»æ“ŠCheck
            if (t >= 7 && !hasCheckedAfterM1M2) {
                hasCheckedAfterM1M2 = true;
                
                // åªæœ‰åœ¨ç¬¬ä¸€æ¬¡é»æ“Šä¸”ç­”å°æ™‚æ‰è§¸ç™¼confetti
                if (iCorrect && jCorrect) {
                    hasTriggeredCelebration = true;
                    successCount++;
                    setTimeout(() => {
                        if (window.confetti) {
                            confetti({
                                particleCount: 120,
                                spread: 90,
                                origin: { y: 0.7 }
                            });
                        }
                        // é¡¯ç¤ºæˆåŠŸæç¤ºæ–¹æ¡†
                        showSuccessModal();
                    }, 200);
                } else {
                    // ç­”éŒ¯æ™‚é‡ç½®æˆåŠŸæ¬¡æ•¸ä¸¦é¡¯ç¤ºå¤±æ•—æç¤ºæ–¹æ¡†
                    successCount = 0;
                    showFailureModal();
                }
            } else if (t < 7) {
                // å¦‚æœé‚„æ²’åˆ°M1M2ç™¼å…‰ï¼Œé¡¯ç¤ºç‰¹æ®Šæç¤º
                if (iCorrect && jCorrect) {
                    // çŒœå°äº†ä½†æ™‚æ©Ÿä¸å°
                    showEarlySuccessModal();
                } else {
                    // çŒœéŒ¯äº†ä¸”æ™‚æ©Ÿä¸å°ï¼Œé‡ç½®æˆåŠŸæ¬¡æ•¸
                    successCount = 0;
                    showEarlyFailureModal();
                }
            }
        }
        
        // é¡¯ç¤ºå¤±æ•—æç¤ºæ–¹æ¡†
        function showFailureModal() {
            createModal('âŒ Wrong Bits Number!', 'Please Try Again! My Friend.', '#f44336');
        }
        
        // é¡¯ç¤ºæ—©æœŸæˆåŠŸæç¤ºæ–¹æ¡†ï¼ˆçŒœå°äº†ä½†æ™‚æ©Ÿä¸å°ï¼‰
        function showEarlySuccessModal() {
            createModal('âœ… You guessed RIGHT!', ' Lucky! But didn\'t pass. Sad...', '#FC5656');
        }
        
        // é¡¯ç¤ºæ—©æœŸå¤±æ•—æç¤ºæ–¹æ¡†ï¼ˆçŒœéŒ¯äº†ä¸”æ™‚æ©Ÿä¸å°ï¼‰
        function showEarlyFailureModal() {
            createModal('ğŸ¤” Don\'t just guess your way through!', 'Got what it takes or not?', '#FF9800');
        }
        
        // é¡¯ç¤ºæœªè¨­ç½®classical bitsçš„å˜²è«·æç¤ºæ–¹æ¡†
        function showUnsetBitsModal() {
            createModal('ğŸ˜ Huh? Is Classical bit a question mark "?"', 'Please set your bits first!', '#9C27B0');
        }
        
        // é¡¯ç¤ºæˆåŠŸæç¤ºæ–¹æ¡†ï¼ˆå‚²å¬Œç‰ˆæœ¬ï¼‰
        function showSuccessModal() {
            let title, message, color;
            
            switch (successCount) {
                case 1:
                    title = 'ğŸ‰ Congrats! But who knows if you just got a lucky guess?ğŸ™„';
                    message = '1/5âœ… ';
                    color = '#FF9800';
                    break;
                case 2:
                    title = 'ğŸ˜’ Tch! Twice correct?! You\'re annoyingly lucky.';
                    message = '2/5âœ… âœ… ';
                    color = '#FF9800';
                    break;
                case 3:
                    title = 'ğŸ˜¤ Hump, no more than three! You\'ll definitely mess up next time.';
                    message = '3/5âœ… âœ… âœ… ';
                    color = '#FF9800';
                    break;
                case 4:
                    title = 'ğŸ¤¨ Just some clever little tricks! Guess I underestimated you.';
                    message = '4/5âœ… âœ… âœ… âœ… ';
                    color = '#FF9800';
                    break;
                case 5:
                    title = 'ğŸ˜®â€ğŸ’¨ Alright, I\'ll admitâ€”you\'ve got some brains';
                    message = 'You\'ve mastered this challenge!ğŸ‘‘';
                    color = '#4CAF50';
                    break;
                default:
                    title = 'ğŸ‰ Congrats! But who knows if you just got a lucky guess?';
                    message = `${successCount}/5`;
                    color = '#FF9800';
            }
            
            createModal(title, message, color);
        }
        
        // é€šç”¨å‰µå»ºæç¤ºæ–¹æ¡†å‡½æ•¸
        function createModal(title, message, color) {
            // å‰µå»ºé®ç½©å±¤
            const overlay = document.createElement('div');
            overlay.id = 'failure-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            // å‰µå»ºæç¤ºæ–¹æ¡†
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                cursor: pointer;
                transition: transform 0.2s;
            `;
            
            modal.innerHTML = `
                <h3 style="color: ${color}; margin-bottom: 15px; font-size: 20px;">${title}</h3>
                <p style="color: #333; margin-bottom: 20px; font-size: 16px;">${message}</p>
                <p style="color: #666; font-size: 14px;">Click to reset and try again</p>
            `;
            
            // é»æ“Šæ–¹æ¡†æ™‚reset
            modal.addEventListener('click', () => {
                document.body.removeChild(overlay);
                resetSimulation();
            });
            
            // æ·»åŠ hoveræ•ˆæœ
            modal.addEventListener('mouseenter', () => {
                modal.style.transform = 'scale(1.05)';
            });
            
            modal.addEventListener('mouseleave', () => {
                modal.style.transform = 'scale(1)';
            });
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–éŠæˆ²
        window.addEventListener('load', function() {
            setTimeout(initGame, 100);
            setTimeout(updateDescriptor, 200);
            setTimeout(checkAndUpdateCNOTColors, 300);
            setTimeout(updateTimeStepDisplay, 400); // åˆå§‹åŒ–æ™‚é–“æ­¥é¡¯ç¤º
        });
        
        // éŸ¿æ‡‰å¼èª¿æ•´
        window.addEventListener('resize', function() {
            if (renderer && camera) {
                const container = document.getElementById('game-container');
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>
