<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entanglement - Level 3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f0f0f0;
            height: 1vh;
            overflow: hidden;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content {
            flex: 1;
            padding: 10px;
            background: none;
            overflow: hidden;
        }

        .block {
            display: none;
            height: 100%;
            border: 1px solid #ccc;
            box-shadow: 0 4px 16px 0 rgba(0,0,0,0.15), 0 1.5px 4px 0 rgba(0,0,0,0.10);
            background-color: #fffff0;
            overflow: hidden;
        }

        .block.active {
            display: block;
        }

        .block h2 {
            color: #2f4f78;
            margin: 10px;
            font-size: 18px;
            font-weight: bold;
            background: rgba(255,255,255,0.85);
            padding: 5px 10px;
            border-radius: 5px;
            display: inline-block;
        }

        .block-content {
            padding: 10px;
            height: calc(100% - 50px);
            overflow: hidden;
        }

        .highlight {
            background: #ffe9b3;
            color: #333;
            padding: 10px;
            border: 1px solid #ccc;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .card {
            background: #fffff0;
            padding: 10px;
            border: 1px solid #ccc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #2f4f78;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .card p {
            color: #333;
            font-size: 12px;
        }

        /* Block 1 ä½ˆå±€ */
        .block1-layout {
            display: flex;
            gap: 5px;
            height: 100%;
            width: 100%;
        }

        /* å·¦å´å€åŸŸ */
        .left-panel {
            width: 66.67%;
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0;
        }

        /* Monitor å€åŸŸ */
        #monitor {
            height: 25%;
            background: #fffff0;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* Monitor å…§éƒ¨ä½ˆå±€ */
        .monitor-layout {
            display: flex;
            gap: 10px;
            width: 100%;
            height: 100%;
        }
        
        /* å·¦å´ Descriptor å€åŸŸ */
        .descriptor-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* å³å´ Expectation Value å€åŸŸ */
        .expectation-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        /* Monitor å­å€å¡Šæ¨£å¼ */
        .monitor-block {
            flex: 1;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1px;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .monitor-block h4 {
            margin: 0 0 5px 0;
            font-size: 12px;
            color: #2f4f78;
            font-weight: bold;
        }
        
        .monitor-block .content {
            flex: 1;
            font-size: 15px;
            color: #333;
            overflow-y: auto;
        }
        
        /* Run Button æ¨£å¼ */
        .run-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
            margin-left: 10px;
            flex-shrink: 0;
        }
        
        .run-button:hover {
            background: #45a049;
        }
        
        .run-button:active {
            background: #3d8b40;
        }
        
        /* Monitor å…§å®¹å€åŸŸ */
        .monitor-content {
            flex: 1;
            overflow-y: auto;
        }

        /* Three.js å®¹å™¨æ¨£å¼ */
        #game-container {
            height: 75%;
            background: #f0f0f0;
            border: 1px solid #ccc;
            overflow: hidden;
            position: relative;
            flex-shrink: 0;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* æ–‡å­—å…§å®¹å€åŸŸ */
        #text-content {
            width: 33.33%;
            background: #ffe9b3;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-y: auto;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }
        
        #text-content.collapsed {
            width: 50px;
            overflow: hidden;
        }
        
        #text-content.collapsed .content-label {
            transform: rotate(90deg);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        
        /* åˆ‡æ›æŒ‰éˆ•æ¨£å¼ */
        .toggle-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #0b538f;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: background-color 0.3s;
            z-index: 15;
        }
        
        .toggle-button:hover {
            background: #094076;
        }
        
        /* å€åŸŸæ¨™ç±¤æ¨£å¼ */
        .area-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(47, 79, 120, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        .content-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(47, 79, 120, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        
        /* Reset Button æ¨£å¼ */
        .reset-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #f44336;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
            z-index: 10;
        }
        
        .reset-button:hover {
            background: #d32f2f;
        }
        
        .reset-button:active {
            background: #b71c1c;
        }
        
        /* Time Step Display æ¨£å¼ */
        .time-step-display {
            position: absolute;
            top: 5px;
            right: 70px;
            background: #2196F3;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
            min-width: 50px;
            text-align: center;
        }
        
        /* èª¿æ•´å®¹å™¨ç‚ºç›¸å°å®šä½ä»¥æ”¯æŒçµ•å°å®šä½çš„æ¨™ç±¤ */
        #monitor, #game-container, #text-content {
            position: relative;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Confetti CDN -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="block active" id="block0">
                <h2 style="font-family: Georgia, serif; font-size: 20px;">Level 3 - Build an Entangled Descriptor Pair</h2>
                <div class="block-content">
                    <div class="block1-layout">
                        <div class="left-panel">
                            <div id="monitor">
                                <div class="monitor-layout">
                                    <div class="descriptor-panel">
                                        <div class="monitor-block">
                                            <h4>Descriptor Q1</h4>
                                            <div class="content">
                                                <!-- Descriptor 1 å…§å®¹ -->
                                                <p>
                                                  Q1 = (X1,Z1)
                                                </p>
                                            </div>
                                        </div>
                                        <div class="monitor-block">
                                            <h4>Descriptor Q2</h4>
                                            <div class="content">
                                                <!-- Descriptor 2 å…§å®¹ -->
                                                <p>
                                                  Q2 = (X2,Z2)
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="expectation-panel">
                                        <div class="monitor-block">
                                            <h4>Expectation Value Q1</h4>
                                            <div class="content">
                                                <!-- Expectation Value 1 å…§å®¹ -->
                                                <p>
                                                  Exc.X(Q1) = 0,    Exc.Z(Q1) = 1
                                                </p>
                                            </div>
                                        </div>
                                        <div class="monitor-block">
                                            <h4>Expectation Value Q2</h4>
                                            <div class="content">
                                                <!-- Expectation Value 2 å…§å®¹ -->
                                                <p>
                                                  Exc.X(Q2) = 0,    Exc.Z(Q2) = 1
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button class="run-button" onclick="runSimulation()">Run</button>
                            </div>
                            <div id="game-container">
                                <div class="area-label">Game Area</div>
                                <div class="time-step-display" id="time-step-display">t = 0</div>
                                <button class="reset-button" onclick="resetSimulation()">Reset</button>
                                <canvas id="game-canvas"></canvas>
                            </div>
                        </div>
                        <div id="text-content" class="collapsed">
                            <div class="content-label">About Bell State</div>
                            <button class="toggle-button" onclick="toggleTextContent()">Show</button>
                            <div class="text-content-inner" style="margin-top: 40px; padding: 10px; display: none;">
                                <h3 style="color: #2f4f78; margin-bottom: 15px;">Level 3 - Build an Entangled Descriptor Pair</h3>
                                
                                <p style="margin-bottom: 10px; line-height: 1.5;">
                                    Now, you can arrange different combinations of Hadamard and CNOT gates to build a simple 
                                    entangled Bell state.
                                </p>
                                
                                <button class="instructions-toggle" onclick="toggleInstructions()" style="background: #2f4f78; color: white; border: none; padding: 1px 2px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; margin: 15px 0 8px 0;">Instructions â–¼</button>
                                <div id="instructions-content" style="display: none; margin-left: 20px;">
                                    <ul style="margin-left: 20px; line-height: 1.4;">
                                        <li>Click "I" boxes to change the operation</li>
                                        <li>Descriptor monitor shows the evolution of the descriptor</li>
                                        <li>Click "Run" to start the simulation</li>
                                        <li>Click "Reset" to return to initial operation</li>  
                                        <li>Measurement "M" boxes show the expectation values of the descriptor</li>
                                    </ul>
                                </div>
                                
                                <h4 style="color: #2f4f78; margin: 15px 0 8px 0;">Bell State:</h4>
                                <ul style="margin-left: 20px; line-height: 1.4;">
                                    <li>It is a maximally entangled state with <b>zero</b> expectation value of any Pauli measurement.</li>
                                    <li>Q1, Q2 share the information with each other.</li>
                                    <li>Try to use "H" and "CNOT" gates to generate a Bell state by yourself. ğŸ‰</li>
                                </ul>

                                <button class="expectation-toggle" onclick="toggleExpectation()" style="background: #2f4f78; color: white; border: none; padding: 1px 2px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: bold; margin: 15px 0 8px 0;">Tips â–¼</button>
                                <div id="expectation-content" style="display: none; margin-left: 20px;">
                                    <ul style="margin-left: 20px; line-height: 1.4;">
                                        <li>Q1 will share its descriptor information(X1 or Z1) with Q2.</li>
                                        <li>Q2 will share its descriptor information(X2 or Z2) with Q1.</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function toggleExpectation() {
            const expectationContent = document.getElementById('expectation-content');
            const toggleButton = document.querySelector('.expectation-toggle');
            
            if (expectationContent.style.display === 'none') {
                // å±•é–‹
                expectationContent.style.display = 'block';
                toggleButton.textContent = 'Tips â–²';
            } else {
                // æ”¶èµ·
                expectationContent.style.display = 'none';
                toggleButton.textContent = 'Tips â–¼';
            }
        }

        function showBlock(blockIndex) {
            // éš±è—æ‰€æœ‰å€å¡Š
            const blocks = document.querySelectorAll('.block');
            blocks.forEach(block => {
                block.classList.remove('active');
            });

            // ç§»é™¤æ‰€æœ‰tabçš„activeç‹€æ…‹
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            // é¡¯ç¤ºé¸ä¸­çš„å€å¡Š
            document.getElementById(`block${blockIndex}`).classList.add('active');
            
            // æ¿€æ´»é¸ä¸­çš„tab
            tabs[blockIndex].classList.add('active');
        }
        
        // åˆ‡æ› Text Content é¡¯ç¤º/éš±è—
        function toggleTextContent() {
            const textContent = document.getElementById('text-content');
            const textContentInner = textContent.querySelector('.text-content-inner');
            const toggleButton = textContent.querySelector('.toggle-button');
            
            if (textContent.classList.contains('collapsed')) {
                // å±•é–‹
                textContent.classList.remove('collapsed');
                textContentInner.style.display = 'block';
                toggleButton.textContent = 'Hide';
            } else {
                // æ”¶èµ·
                textContent.classList.add('collapsed');
                textContentInner.style.display = 'none';
                toggleButton.textContent = 'Show';
            }
        }

        // Three.js éŠæˆ²åˆå§‹åŒ–
        let scene, camera, renderer, boxes = [];
        let raycaster, mouse;
        let animationId;
        let t = 0; // ç•¶å‰æ™‚é–“æ­¥ï¼Œé»˜èª0
        
        function initGame() {
            const container = document.getElementById('game-container');
            const canvas = document.getElementById('game-canvas');
            
            // å‰µå»ºå ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // å‰µå»ºç›¸æ©Ÿ - ä½¿ç”¨é•·ç„¦é¡é ­å¯¦ç¾å¹³é¢3Dæ•ˆæœï¼Œå¾æ­£æ–¹å½¢é ‚é»çœ‹å‘åŸé»
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(15, aspect, 0.1, 1000); // 20åº¦è¦–è§’ = é•·ç„¦
            camera.position.set(-5, 20, 20); // ç§»å‹•åˆ°æ­£æ–¹å½¢é ‚é»ï¼ŒYä¿æŒä¸è®Š
            camera.lookAt(0, 0, 0);
            
            // å‰µå»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // æ·»åŠ ç’°å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            // æ·»åŠ åæ¨™è»¸
            //createAxes();
            
            // å‰µå»ºboxes
            createBoxes();
            
            // å‰µå»ºåº•éƒ¨bars
            createBottomBars();
            
            // åˆå§‹åŒ–äº’å‹•
            initInteraction();
            
            // é–‹å§‹æ¸²æŸ“å¾ªç’°
            animate();
        }
        

        
        function createAxes() {
            // å‰µå»ºåæ¨™è»¸
            const axesHelper = new THREE.AxesHelper(3);
            axesHelper.position.set(0, 0, 0); // æ”¾åœ¨å››å€‹æ ¼å­çš„ä¸­å¿ƒ
            scene.add(axesHelper);
        }
        
        function toggleInstructions() {
            const instructionsContent = document.getElementById('instructions-content');
            const toggleButton = document.querySelector('.instructions-toggle');
            
            if (instructionsContent.style.display === 'none') {
                // å±•é–‹
                instructionsContent.style.display = 'block';
                toggleButton.textContent = 'Instructions â–²';
            } else {
                // æ”¶èµ·
                instructionsContent.style.display = 'none';
                toggleButton.textContent = 'Instructions â–¼';
            }
        }

        function createBottomBars() {
            // Aè¡Œbaråƒæ•¸
            const barWidth = 8.6; // å¯¬åº¦
            const barLength = 0.3; // é•·åº¦ï¼ˆè¦†è“‹A0-A3å››å€‹boxesï¼‰
            const barHeight = 0.01; // åšåº¦
            
            // å‰µå»ºAè¡Œbarå¹¾ä½•é«”
            const barGeometry = new THREE.BoxGeometry(barWidth, barHeight, barLength);
            const barMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xff0000, // ç´…è‰²
                transparent: true,
                opacity: 1
            });
            
            // Aè¡Œbarä½ç½®ï¼ˆåœ¨Aè¡Œboxesåº•éƒ¨ï¼‰
            // Aè¡Œæ˜¯ç¬¬0è¡Œï¼Œä½ç½®åœ¨zè»¸æ­£æ–¹å‘
            const aBar = new THREE.Mesh(barGeometry, barMaterial);
            aBar.position.set(0, 0, -1.1); // æ°´å¹³å±…ä¸­ï¼Œåœ¨Aè¡Œboxesåº•éƒ¨
            scene.add(aBar);
            
            // Bè¡Œbaråƒæ•¸ï¼ˆè—è‰²ï¼‰
            const bBarMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x0000ff, // è—è‰²
                transparent: true,
                opacity: 1
            });
            
            // Bè¡Œbarä½ç½®ï¼ˆåœ¨Bè¡Œboxesåº•éƒ¨ï¼‰
            const bBar = new THREE.Mesh(barGeometry, bBarMaterial);
            bBar.position.set(0, 0, 1.1); // æ°´å¹³å±…ä¸­ï¼Œåœ¨Bè¡Œboxesåº•éƒ¨
            scene.add(bBar);
        }
        
        function createBoxes() {
            const boxWidth = 2;
            const defaultBoxHeight = 0.4;
            const qBoxHeight = 0.9;
            const boxDepth = 2;
            const spacing = 0.2;
            
            // è¨ˆç®—ç¸½å¯¬åº¦å’Œç¸½æ·±åº¦
            const totalWidth = 4 * boxWidth + 3 * spacing;
            const totalDepth = 2 * boxDepth + 1 * spacing;
            
            // è¨ˆç®—èµ·å§‹ä½ç½®ï¼Œä½¿boxeså±…ä¸­
            const startX = -totalWidth / 2 + boxWidth / 2;
            const startZ = -totalDepth / 2 + boxDepth / 2;
            
            // å‰µå»ºå…©è¡Œå››åˆ—çš„boxes
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 4; col++) {
                    // æ±ºå®šé«˜åº¦
                    let boxHeight = (col === 0) ? qBoxHeight : defaultBoxHeight;
                    // å‰µå»ºboxå¹¾ä½•é«”
                    const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
                    
                    // å‰µå»ºæè³ª - æ ¹æ“šæ˜¯å¦ç‚ºå›ºå®šboxè¨­ç½®ä¸åŒæè³ª
                    let material;
                    if (col === 0) {
                        // A0å’ŒB0ï¼šæ·ºè‰²åŠé€æ˜
                        material = new THREE.MeshLambertMaterial({
                            color: 0xcccccc, // æ·ºç°è‰²
                            transparent: true,
                            opacity: 0.85
                        });
                    } else if (col === 3) {
                        // A3å’ŒB3ï¼šæ¯”A0æ·±ä¸€äº›çš„é¡è‰²
                        material = new THREE.MeshLambertMaterial({
                            color: 0xb8b8b8, // æ¯”A0æ·±ä¸€äº›çš„ç°è‰²
                            transparent: true,
                            opacity: 0.85
                        });
                    } else {
                        // å…¶ä»–boxesï¼šæ·±ç°è‰²ä¸é€æ˜
                        material = new THREE.MeshLambertMaterial({
                            color: 0x808080,
                            transparent: true,
                            opacity: 1
                        });
                    }
                    
                    // å‰µå»ºmesh
                    const box = new THREE.Mesh(geometry, material);
                    
                    // è¨ˆç®—ä½ç½®
                    const x = startX + col * (boxWidth + spacing);
                    const y = boxHeight / 2; // è®“boxåº•éƒ¨è²¼åœ°
                    const z = startZ + row * (boxDepth + spacing);
                    
                    box.position.set(x, y, z);
                    
                    // å‰µå»ºé‚Šç·šä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    const edges = new THREE.EdgesGeometry(geometry);
                    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
                    const wireframe = new THREE.LineSegments(edges, lineMaterial);
                    box.add(wireframe); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // å‰µå»ºä½ç½®æ¨™ç±¤ï¼ˆå³ä¸Šè§’ï¼‰ä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    // const positionLabel = createLabel(row === 0 ? `A${col}` : `B${col}`);
                    // positionLabel.position.set(boxWidth/2 - 0.3, boxHeight/2 + 0.01, -boxDepth/2 + 0.3);
                    // box.add(positionLabel); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // å‰µå»ºç‹€æ…‹æ¨™ç±¤ï¼ˆé ‚é¢ä¸­å¤®ï¼‰ä¸¦ä½œç‚ºboxçš„å­ç‰©ä»¶
                    let centerText = "I";
                    if (col === 0) {
                        // A0å’ŒB0ä½¿ç”¨Q1å’ŒQ2
                        centerText = row === 0 ? "Q1" : "Q2";
                    } else if (col === 3) {
                        // A3å’ŒB3ä½¿ç”¨M1å’ŒM2
                        centerText = row === 0 ? "M1" : "M2";
                    }
                    const stateLabel = createLabel(centerText);
                    stateLabel.position.set(0, boxHeight/2 + 0.02, 0);
                    stateLabel.rotation.x = -Math.PI / 2; // æ—‹è½‰90åº¦å¹³è²¼åœ¨é ‚é¢
                    box.add(stateLabel); // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
                    
                    // æ·»åŠ ç”¨æˆ¶æ•¸æ“š
                    box.userData = { 
                        state: centerText, // ä½¿ç”¨å¯¦éš›é¡¯ç¤ºçš„æ–‡å­—ä½œç‚ºç‹€æ…‹
                        wireframe: wireframe,
                        // positionLabel: positionLabel, // å·²ç§»é™¤ä½ç½®æ¨™ç±¤
                        stateLabel: stateLabel,
                        isFixed: col === 0 || col === 3, // ç¬¬0åˆ—å’Œç¬¬3åˆ—ï¼ˆA0ã€B0ã€A3ã€B3ï¼‰ç‚ºå›ºå®šä¸å¯äº’å‹•
                        boxHeight: boxHeight
                    };
                    
                    // åªæ·»åŠ boxåˆ°å ´æ™¯å’Œboxesæ•¸çµ„
                    scene.add(box);
                    boxes.push(box);
                }
            }
        }
        
        function createLabel(text) {
            // å‰µå»ºCanvasä¾†ç¹ªè£½æ–‡å­—
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            // æ¸…é™¤CanvasèƒŒæ™¯ï¼Œç¢ºä¿é€æ˜
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // åˆ¤æ–·æ˜¯å¦ç‚ºç‹€æ…‹æ¨™ç±¤ï¼ˆIã€Hã€â€¢ã€â¨ã€Q1ã€Q2ã€M1æˆ–M2ï¼‰
            const isStateLabel = text === 'I' || text === 'H' || text === 'â€¢' || text === 'â¨' || text === 'Q1' || text === 'Q2' || text === 'M1' || text === 'M2';
            
            // è¨­ç½®æ–‡å­—æ¨£å¼
            if (isStateLabel) {
                if (text === 'Q1' || text === 'Q2' || text === 'M1' || text === 'M2') {
                    // Q1ã€Q2ã€M1ã€M2ï¼šæ·±è‰²
                    context.fillStyle = '#333333'; // æ·±ç°è‰²
                } else {
                    // Iã€Hã€â€¢ã€â¨ï¼šæ·ºè‰²
                    context.fillStyle = '#E0E0E0'; // æ·ºç°è‰²
                }
                context.font = 'bold 180px Georgia';
            } else {
                // ä½ç½®æ¨™ç±¤ï¼šæ ¹æ“šå…§å®¹è¨­ç½®é¡è‰²
                if (text === 'X1' || text === 'Z1') {
                    context.fillStyle = '#ff0000'; // ç´…è‰²ï¼Œèˆ‡ç´…è‰²barä¸€è‡´
                } else if (text === 'X2' || text === 'Z2') {
                    context.fillStyle = '#0000ff'; // è—è‰²ï¼Œèˆ‡è—è‰²barä¸€è‡´
                } else {
                    context.fillStyle = '#000000'; // å…¶ä»–ä½ç½®æ¨™ç±¤ä¿æŒé»‘è‰²
                }
                context.font = 'bold 100px Arial';
            }
            
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // ç¹ªè£½æ–‡å­—
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // å‰µå»ºæè³ª - å•Ÿç”¨é€æ˜é€šé“
            const texture = new THREE.CanvasTexture(canvas);
            texture.premultiplyAlpha = false;
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1, // è¨­ç½®alphaæ¸¬è©¦é–¾å€¼
                side: THREE.DoubleSide
            });
            
            // å‰µå»ºå¹³é¢å¹¾ä½•é«”ä½œç‚ºæ¨™ç±¤
            const geometry = new THREE.PlaneGeometry(0.8, 0.8);
            const label = new THREE.Mesh(geometry, material);
            
            // è®“æ¨™ç±¤æœå‘Yæ–¹å‘ï¼ˆå‚ç›´å‘ä¸Šï¼‰
            label.rotation.x = -Math.PI / 2; // æ—‹è½‰90åº¦ï¼Œè®“æ¨™ç±¤å‚ç›´å‘ä¸Š
            
            return label;
        }
        

        
        function animate() {
            animationId = requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function initInteraction() {
            // åˆå§‹åŒ–å°„ç·šæª¢æ¸¬å™¨å’Œæ»‘é¼ 
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨
            const canvas = document.getElementById('game-canvas');
            canvas.addEventListener('click', onMouseClick);
        }
        
        function onMouseClick(event) {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // è¨ˆç®—æ»‘é¼ åœ¨ç•«å¸ƒä¸­çš„æ¨™æº–åŒ–åº§æ¨™
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // æ›´æ–°å°„ç·š
            raycaster.setFromCamera(mouse, camera);
            
            // æª¢æ¸¬èˆ‡ boxes çš„ç›¸äº¤
            const intersects = raycaster.intersectObjects(boxes);
            
            if (intersects.length > 0) {
                const clickedBox = intersects[0].object;
                // æª¢æŸ¥æ˜¯å¦ç‚ºå›ºå®šboxï¼Œå¦‚æœæ˜¯å‰‡ä¸åŸ·è¡Œé»æ“Šæ•ˆæœ
                if (!clickedBox.userData.isFixed) {
                    changeBoxColor(clickedBox);
                }
            }
        }
        
        function changeBoxColor(box) {
            // æª¢æŸ¥ç•¶å‰ç‹€æ…‹ä¸¦æŒ‰ç…§ I â†’ H â†’ â€¢ â†’ â¨ çš„é †åºå¾ªç’°
            if (box.userData.state === "I") {
                // å¾ "I" è®Šæˆ "H"
                box.userData.state = "H";
                box.material.color.setHex(0x3498db); // è—è‰²
                updateStateLabel(box, "H");
            } else if (box.userData.state === "H") {
                // å¾ "H" è®Šæˆ "â€¢"
                box.userData.state = "â€¢";
                box.material.color.setHex(0x808080); // ç°è‰²ï¼Œèˆ‡Iç›¸åŒ
                updateStateLabel(box, "â€¢");
            } else if (box.userData.state === "â€¢") {
                // å¾ "â€¢" è®Šæˆ "â¨"
                box.userData.state = "â¨";
                box.material.color.setHex(0x808080); // ç°è‰²ï¼Œèˆ‡Iç›¸åŒ
                updateStateLabel(box, "â¨");
            } else {
                // å¾ "â¨" è®Šå› "I"
                box.userData.state = "I";
                box.material.color.setHex(0x808080); // ç°è‰²
                updateStateLabel(box, "I");
            }
            
            // è§¸ç™¼æœå‡æŠ–å‹•ç‰¹æ•ˆ
            triggerJellyEffect(box);
            
            // æª¢æŸ¥CNOT gateè¦å‰‡ä¸¦æ›´æ–°é¡è‰²
            checkAndUpdateCNOTColors();
        }
        
        function updateStateLabel(box, text) {
            // ç§»é™¤èˆŠçš„ç‹€æ…‹æ¨™ç±¤
            box.remove(box.userData.stateLabel);
            
            // å‰µå»ºæ–°çš„ç‹€æ…‹æ¨™ç±¤
            const newStateLabel = createLabel(text);
            newStateLabel.position.copy(box.userData.stateLabel.position);
            newStateLabel.rotation.copy(box.userData.stateLabel.rotation);
            
            // æ›´æ–°ç”¨æˆ¶æ•¸æ“š
            box.userData.stateLabel = newStateLabel;
            
            // ä½œç‚ºå­ç‰©ä»¶æ·»åŠ åˆ°box
            box.add(newStateLabel);
        }
        
        function triggerJellyEffect(box) {
            // ä¿å­˜åŸå§‹ä½ç½®
            const originalY = box.position.y;
            
            // æŠ–å‹•åƒæ•¸
            const duration = 700; // 0.7ç§’
            const amplitude = 0.15; // æŠ–å‹•å¹…åº¦
            const frequency = 9; // æŠ–å‹•é »ç‡
            const startTime = Date.now();
            
            function jellyAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    // ä½¿ç”¨è¡°æ¸›çš„æ­£å¼¦æ³¢å‰µå»ºæœå‡æ•ˆæœ
                    const decay = Math.exp(-progress * 3); // è¡°æ¸›å› å­
                    const oscillation = Math.sin(progress * frequency * Math.PI) * decay;
                    
                    // åªæœ‰ä¸Šä¸‹æŠ–å‹•ï¼Œä¸æ”¹è®Šå¤§å°
                    box.position.y = originalY + oscillation * amplitude;
                    
                    requestAnimationFrame(jellyAnimation);
                } else {
                    // æ¢å¾©åŸå§‹ä½ç½®
                    box.position.y = originalY;
                }
            }
            
            jellyAnimation();
        }
        
        // Q1/Q2æè¿°å­ç‹€æ…‹
        let q1Left = 'X1', q1Right = 'Z1';
        let q2Left = 'X2', q2Right = 'Z2';
        
        // Bell StateæˆåŠŸåˆ¤å®šæ¨™è¨˜
        let hasTriggeredBellStateCelebration = false;
        
        // ç…™èŠ±ç‰¹æ•ˆé…ç½®
        const FIREWORK_CONFIG = {
            // ä¸»è¦çˆ†ç‚¸
            main: {
                particleCount: 250,
                spread: 65,
                startVelocity: 40,
                gravity: 0.6,
                drift: 0.15,
                ticks: 300,
                origin: { y: 0.7 },
                colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#800080', '#ff6b6b', '#4ecdc4', '#ff4757', '#2ed573'],
                shapes: ['circle', 'square'],
                scalar: 1.4,
                zIndex: 1000,
                disableForReducedMotion: false
            },
            // æ“´æ•£æ•ˆæœ
            spread: {
                particleCount: 150,
                spread: 85,
                startVelocity: 32,
                gravity: 0.75,
                drift: 0.25,
                ticks: 220,
                origin: { y: 0.65 },
                colors: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8', '#f7dc6f', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3'],
                shapes: ['circle'],
                scalar: 1.1,
                zIndex: 1001,
                disableForReducedMotion: false
            },
            // å°¾éš¨æ•ˆæœ
            trail: {
                particleCount: 100,
                spread: 45,
                startVelocity: 22,
                gravity: 0.85,
                drift: 0.12,
                ticks: 200,
                origin: { y: 0.75 },
                colors: ['#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43', '#10ac84', '#ee5a24', '#ff3838', '#ff6348', '#ffa502'],
                shapes: ['circle'],
                scalar: 0.8,
                zIndex: 1002,
                disableForReducedMotion: false
            },
            // å°ç²’å­æ•ˆæœ
            sparkle: {
                particleCount: 80,
                spread: 35,
                startVelocity: 18,
                gravity: 1.1,
                drift: 0.35,
                ticks: 170,
                origin: { y: 0.8 },
                colors: ['#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43', '#10ac84', '#ff6b6b', '#4ecdc4'],
                shapes: ['circle'],
                scalar: 0.6,
                zIndex: 1003,
                disableForReducedMotion: false
            }
        };
        
        // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
        function updateTimeStepDisplay() {
            const timeStepDisplay = document.getElementById('time-step-display');
            if (timeStepDisplay) {
                timeStepDisplay.textContent = `t = ${t}`;
            }
        }

        // Run æŒ‰éˆ•åŠŸèƒ½
        function runSimulation() {
            console.log('Simulation started!');
            
            // æª¢æŸ¥æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
            if (checkInvalidCNOTGates()) {
                console.log('Invalid CNOT gate detected! Showing error...');
                showErrorEffect();
                return; // é˜»æ­¢æ¨¡æ“¬é‹è¡Œ
            }
            
            if (t >= 3) {
                console.log('Simulation completed, cannot run further');
                return;
            }
            
            t++;
            updateTimeStepDisplay(); // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
            addGlowEffectToColumn(t);

            // æª¢æŸ¥Aè¡Œ/Bè¡Œç•¶å‰tåˆ—boxç‹€æ…‹
            const aBox = boxes[t]; // row=0, col=t
            const bBox = boxes[4 + t]; // row=1, col=t
            if (aBox.userData.state === 'H') {
                // Q1å·¦å³äº’æ›
                [q1Left, q1Right] = [q1Right, q1Left];
            }
            if (bBox.userData.state === 'H') {
                // Q2å·¦å³äº’æ›
                [q2Left, q2Right] = [q2Right, q2Left];
            }

            // CNOT descriptor é‹ç®—ï¼ˆåœ¨Hadamardä¹‹å¾Œï¼‰
            executeCNOTLogicForColumn(t);

            updateDescriptor();

            if (t >= 3) {
                const runButton = document.querySelector('.run-button');
                runButton.disabled = true;
                runButton.style.background = '#cccccc';
                runButton.style.cursor = 'not-allowed';
            }
            console.log(`Time step: t = ${t}`);
        }

        // æ›´æ–°monitorå…§çš„descriptoré¡¯ç¤º
        function updateDescriptor() {
            const q1Elem = document.querySelector('.descriptor-panel .monitor-block:nth-child(1) .content p');
            const q2Elem = document.querySelector('.descriptor-panel .monitor-block:nth-child(2) .content p');
            
            if (q1Elem) {
                let html = `Q1 = (<span>${q1Left}</span>,<span>${q1Right}</span>)`;
                html = html.replace(/X1|Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/X2|Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>');
                q1Elem.innerHTML = html;
            }
            if (q2Elem) {
                let html = `Q2 = (<span>${q2Left}</span>,<span>${q2Right}</span>)`;
                html = html.replace(/X1|Z1/g, '<span style="color:#ff0000;font-weight:bold;">$&</span>')
                           .replace(/X2|Z2/g, '<span style="color:#0000ff;font-weight:bold;">$&</span>');
                q2Elem.innerHTML = html;
            }
            
            // æ›´æ–°Expectation Values
            updateExpectationValues();
        }
        
        // æ›´æ–°Expectation Values
        function updateExpectationValues() {
            // æª¢æŸ¥M1å’ŒM2æ˜¯å¦ç™¼å…‰ï¼ˆt=3æ™‚ï¼‰
            if (t < 3) {
                // å¦‚æœé‚„æ²’åˆ°M1M2ç™¼å…‰çš„æ™‚å€™ï¼Œé¡¯ç¤ºç­‰å¾…ç‹€æ…‹
                const q1ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(1) .content p');
                const q2ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(2) .content p');
                
                if (q1ExpectElem) {
                    q1ExpectElem.textContent = `Exc.X(Q1) = ?,    Exc.Z(Q1) = ?`;
                }
                if (q2ExpectElem) {
                    q2ExpectElem.textContent = `Exc.X(Q2) = ?,    Exc.Z(Q2) = ?`;
                }
                return;
            }
            
            // åªæœ‰åœ¨M1M2ç™¼å…‰æ™‚æ‰è¨ˆç®—Expectation Values
            // è¨ˆç®—Q1çš„Expectation Values
            const excXQ1 = q1Left.includes('X') ? 0 : 1;
            const excZQ1 = q1Right.includes('X') ? 0 : 1;
            
            // è¨ˆç®—Q2çš„Expectation Values
            const excXQ2 = q2Left.includes('X') ? 0 : 1;
            const excZQ2 = q2Right.includes('X') ? 0 : 1;
            
            // æ›´æ–°é¡¯ç¤º
            const q1ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(1) .content p');
            const q2ExpectElem = document.querySelector('.expectation-panel .monitor-block:nth-child(2) .content p');
            
            if (q1ExpectElem) {
                q1ExpectElem.innerHTML = `Exc.X(Q1) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excXQ1}</span></strong>,    Exc.Z(Q1) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excZQ1}</span></strong>`;
            }
            if (q2ExpectElem) {
                q2ExpectElem.innerHTML = `Exc.X(Q2) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excXQ2}</span></strong>,    Exc.Z(Q2) = <strong><span style="background-color: yellow; padding: 2px 4px; border-radius: 3px;">${excZQ2}</span></strong>`;
            }
            
            // æª¢æŸ¥Bell StateæˆåŠŸæ¢ä»¶
            checkBellStateSuccess();
        }

        // ç‚ºæŒ‡å®šåˆ—çš„boxesæ·»åŠ ç™¼å…‰æ•ˆæœ
        function addGlowEffectToColumn(columnIndex) {
            boxes.forEach((box, index) => {
                const row = Math.floor(index / 4); // 0æˆ–1
                const col = index % 4; // 0, 1, 2, 3
                
                if (col === columnIndex) {
                    // ç‚ºè©²åˆ—çš„boxesæ·»åŠ ç™¼å…‰æ•ˆæœ
                    addGlowEffect(box);
                }
            });
        }
        
        // ç‚ºå–®å€‹boxæ·»åŠ ç™¼å…‰æ•ˆæœ
        function addGlowEffect(box) {
            // ä¿å­˜åŸå§‹æè³ª
            const originalMaterial = box.material;
            
            // å‰µå»ºç™¼å…‰æè³ª
            const glowMaterial = originalMaterial.clone();
            
            // æ ¹æ“šboxçš„åŸå§‹é¡è‰²è¨­ç½®ç›¸è¿‘çš„ç™¼å…‰é¡è‰²
            const originalColor = originalMaterial.color;
            glowMaterial.emissive = originalColor.clone(); // ä½¿ç”¨èˆ‡boxç›¸åŒçš„é¡è‰²
            glowMaterial.emissiveIntensity = 0.4; // é©ä¸­çš„ç™¼å…‰å¼·åº¦
            
            // æ‡‰ç”¨ç™¼å…‰æè³ª
            box.material = glowMaterial;
            
            // ä¿å­˜åŸå§‹æè³ªä»¥ä¾¿å¾ŒçºŒæ¢å¾©
            box.userData.originalMaterial = originalMaterial;
            
            // æ·»åŠ é«˜åº¦å¢é«˜æ•ˆæœ
            addHeightEffect(box);
        }
        
        // ç‚ºboxæ·»åŠ é«˜åº¦å¢é«˜æ•ˆæœ
        function addHeightEffect(box) {
            // ä¿å­˜åŸå§‹Yä½ç½®
            const originalY = box.position.y;
            const targetY = originalY + 0.5; // å¢é«˜0.2
            
            // å‹•ç•«åƒæ•¸
            const duration = 500; // 0.5ç§’
            const startTime = Date.now();
            
            function heightAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    // ä½¿ç”¨ç·©å‹•å‡½æ•¸è®“å‹•ç•«æ›´è‡ªç„¶
                    const easeProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic
                    
                    // è¨ˆç®—æ–°çš„Yä½ç½®
                    const newY = originalY + (targetY - originalY) * easeProgress;
                    box.position.y = newY;
                    
                    requestAnimationFrame(heightAnimation);
                } else {
                    // å‹•ç•«çµæŸï¼Œè¨­ç½®åˆ°ç›®æ¨™ä½ç½®
                    box.position.y = targetY;
                }
            }
            
            heightAnimation();
        }
        
        // æ¸…é™¤æ‰€æœ‰boxesçš„ç™¼å…‰æ•ˆæœ
        function clearAllGlowEffects() {
            boxes.forEach(box => {
                if (box.userData.originalMaterial) {
                    box.material = box.userData.originalMaterial;
                    delete box.userData.originalMaterial;
                }
            });
        }
        
        // Reset åŠŸèƒ½
        function resetSimulation() {
            console.log('Simulation reset!');
            t = 0;
            updateTimeStepDisplay(); // æ›´æ–°æ™‚é–“æ­¥é¡¯ç¤º
            clearAllGlowEffects();
            // é‡ç½®Q1/Q2æè¿°å­
            q1Left = 'X1'; q1Right = 'Z1';
            q2Left = 'X2'; q2Right = 'Z2';
            // é‡ç½®Bell StateæˆåŠŸæ¨™è¨˜
            hasTriggeredBellStateCelebration = false;
            updateDescriptor();
            boxes.forEach((box, idx) => {
                const currentState = box.userData.state;
                const isFixed = box.userData.isFixed;
                const col = idx % 4;
                if (col !== 0) {
                    box.position.y = box.userData.boxHeight / 2;
                }
                box.userData.state = currentState;
                box.userData.isFixed = isFixed;
            });
            const runButton = document.querySelector('.run-button');
            runButton.disabled = false;
            runButton.style.background = '#4CAF50';
            runButton.style.cursor = 'pointer';
            console.log('Simulation reset to t = 0');
        }
        
        // æª¢æŸ¥ä¸¦æ›´æ–°CNOT gateé¡è‰²
        function checkAndUpdateCNOTColors() {
            // å®šç¾©4åˆ—çš„ä½ˆå±€
            // ç¬¬0åˆ—ï¼šboxes[0], boxes[4] (A0, B0) - å›ºå®šboxes
            // ç¬¬1åˆ—ï¼šboxes[1], boxes[5] (A1, B1) - å¯äº’å‹•boxes
            // ç¬¬2åˆ—ï¼šboxes[2], boxes[6] (A2, B2) - å¯äº’å‹•boxes
            // ç¬¬3åˆ—ï¼šboxes[3], boxes[7] (A3, B3) - å›ºå®šboxes
            
            const column0 = [boxes[0], boxes[4]]; // ç¬¬0åˆ—
            const column1 = [boxes[1], boxes[5]]; // ç¬¬1åˆ—
            const column2 = [boxes[2], boxes[6]]; // ç¬¬2åˆ—
            const column3 = [boxes[3], boxes[7]]; // ç¬¬3åˆ—
            
            // æª¢æŸ¥æ¯ä¸€åˆ—
            checkColumnForCNOT(column0);
            checkColumnForCNOT(column1);
            checkColumnForCNOT(column2);
            checkColumnForCNOT(column3);
        }
        
        // --- CNOT descriptor é‹ç®—èˆ‡æŠµéŠ· ---
        function cancelIdenticalOperators(expression) {
            if (!expression || expression === '1') return '1';
            const operators = expression.match(/(X\d|Z\d)/g) || [];
            if (operators.length === 0) return '1';
            const operatorCount = {};
            operators.forEach(op => {
                operatorCount[op] = (operatorCount[op] || 0) + 1;
            });
            const remainingOperators = [];
            Object.keys(operatorCount).forEach(op => {
                if (operatorCount[op] % 2 === 1) remainingOperators.push(op);
            });
            if (remainingOperators.length === 0) return '1';
            return remainingOperators.join('');
        }

        function executeCNOTLogicForColumn(colIdx) {
            // å–å¾—è©²åˆ—çš„å…©å€‹box
            const aBox = boxes[colIdx];
            const bBox = boxes[4 + colIdx];
            // åªæœ‰åŒæ™‚å­˜åœ¨ä¸”ç‚ºåœŸé»ƒè‰²æ‰åŸ·è¡Œ
            if (!((aBox.userData.state === 'â€¢' && bBox.userData.state === 'â¨') || (aBox.userData.state === 'â¨' && bBox.userData.state === 'â€¢'))) return;
            if (!(aBox.material.color.getHex() === 0xd4af37 && bBox.material.color.getHex() === 0xd4af37)) return;
            // å–å¾— Q1/Q2 ç•¶å‰æè¿°å­
            let q1L = q1Left, q1R = q1Right, q2L = q2Left, q2R = q2Right;
            // æ±ºå®šèª°æ˜¯ dot èª°æ˜¯ xor
            let dotIsQ1 = (aBox.userData.state === 'â€¢');
            let newQ1Left, newQ1Right, newQ2Left, newQ2Right;
            if (dotIsQ1) {
                // Q1: â€¢, Q2: â¨
                newQ1Left = q1L + q2L;
                newQ1Right = q1R;
                newQ2Left = q2L;
                newQ2Right = q1R + q2R;
            } else {
                // Q2: â€¢, Q1: â¨
                newQ2Left = q2L + q1L;
                newQ2Right = q2R;
                newQ1Left = q1L;
                newQ1Right = q2R + q1R;
            }
            // æŠµéŠ·
            q1Left = cancelIdenticalOperators(newQ1Left);
            q1Right = cancelIdenticalOperators(newQ1Right);
            q2Left = cancelIdenticalOperators(newQ2Left);
            q2Right = cancelIdenticalOperators(newQ2Right);
            updateDescriptor();
        }

        // æª¢æŸ¥æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
        function checkInvalidCNOTGates() {
            // å®šç¾©4åˆ—çš„ä½ˆå±€
            const column0 = [boxes[0], boxes[4]]; // ç¬¬0åˆ—
            const column1 = [boxes[1], boxes[5]]; // ç¬¬1åˆ—
            const column2 = [boxes[2], boxes[6]]; // ç¬¬2åˆ—
            const column3 = [boxes[3], boxes[7]]; // ç¬¬3åˆ—
            
            // æª¢æŸ¥æ¯ä¸€åˆ—æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gate
            const column0Invalid = checkColumnForCNOT(column0);
            const column1Invalid = checkColumnForCNOT(column1);
            const column2Invalid = checkColumnForCNOT(column2);
            const column3Invalid = checkColumnForCNOT(column3);
            
            return column0Invalid || column1Invalid || column2Invalid || column3Invalid;
        }
        
        function checkColumnForCNOT(columnBoxes) {
            let hasDot = false;
            let hasXOR = false;
            let dotBox = null;
            let xorBox = null;
            
            // æª¢æŸ¥é€™ä¸€åˆ—æ˜¯å¦æœ‰"â€¢"å’Œ"â¨"
            for (let box of columnBoxes) {
                if (box.userData.state === "â€¢") {
                    hasDot = true;
                    dotBox = box;
                } else if (box.userData.state === "â¨") {
                    hasXOR = true;
                    xorBox = box;
                }
            }
            
            // å¦‚æœåŒæ™‚å­˜åœ¨"â€¢"å’Œ"â¨"ï¼Œå°‡å®ƒå€‘è®Šæˆé»ƒè‰²
            if (hasDot && hasXOR) {
                console.log("CNOT gate detected! Changing â€¢ and â¨ to yellow");
                
                // å°‡"â€¢"è®ŠæˆåœŸé»ƒè‰²
                dotBox.material.color.setHex(0xd4af37); // åœŸé»ƒè‰²
                
                // å°‡"â¨"è®ŠæˆåœŸé»ƒè‰²
                xorBox.material.color.setHex(0xd4af37); // åœŸé»ƒè‰²
                
            } else {
                // å¦‚æœæ²’æœ‰åŒæ™‚å­˜åœ¨ï¼Œé¡¯ç¤ºç‚ºæ·¡é»ƒè‰²
                for (let box of columnBoxes) {
                    if (box.userData.state === "â€¢" || box.userData.state === "â¨") {
                        box.material.color.setHex(0xb8b89a); // æ·¡é»ƒç°è‰²ï¼Œèˆ‡Iç›¸è¿‘
                    }
                }
            }
            
            // è¿”å›æ˜¯å¦æœ‰ç„¡æ•ˆçš„CNOT gateï¼ˆåªæœ‰ä¸€å€‹"â€¢"æˆ–"â¨"ï¼‰
            return (hasDot && !hasXOR) || (!hasDot && hasXOR);
        }
        
        // è§¸ç™¼çœŸå¯¦ç…™èŠ±ç‰¹æ•ˆ
        function triggerRealisticFireworks() {
            if (!window.confetti) return;
            
            // ç¬¬ä¸€æ³¢ï¼šä¸»è¦ç…™èŠ±çˆ†ç‚¸
            confetti(FIREWORK_CONFIG.main);
            
            // ç¬¬äºŒæ³¢ï¼šæ“´æ•£æ•ˆæœ
            setTimeout(() => {
                confetti(FIREWORK_CONFIG.spread);
            }, 200);
            
            // ç¬¬ä¸‰æ³¢ï¼šå°¾éš¨æ•ˆæœ
            setTimeout(() => {
                confetti(FIREWORK_CONFIG.trail);
            }, 400);
            
            // ç¬¬å››æ³¢ï¼šå°ç²’å­æ•ˆæœ
            setTimeout(() => {
                confetti(FIREWORK_CONFIG.sparkle);
            }, 600);
            
            // é¡å¤–çš„éš¨æ©Ÿå°çˆ†ç‚¸æ•ˆæœ - å·¦å´
            setTimeout(() => {
                confetti({
                    ...FIREWORK_CONFIG.sparkle,
                    particleCount: 45,
                    spread: 25,
                    startVelocity: 15,
                    origin: { y: 0.85, x: 0.25 }
                });
            }, 750);
            
            // é¡å¤–çš„éš¨æ©Ÿå°çˆ†ç‚¸æ•ˆæœ - å³å´
            setTimeout(() => {
                confetti({
                    ...FIREWORK_CONFIG.sparkle,
                    particleCount: 35,
                    spread: 30,
                    startVelocity: 13,
                    origin: { y: 0.9, x: 0.75 }
                });
            }, 950);
            
            // æœ€å¾Œçš„é–ƒçˆæ•ˆæœ
            setTimeout(() => {
                confetti({
                    particleCount: 20,
                    spread: 15,
                    startVelocity: 8,
                    gravity: 1.2,
                    drift: 0.2,
                    ticks: 120,
                    origin: { y: 0.95, x: 0.5 },
                    colors: ['#ffffff', '#ffff00', '#ff9ff3', '#54a0ff'],
                    shapes: ['circle'],
                    scalar: 0.4,
                    zIndex: 1004
                });
            }, 1200);
        }
        
        // æª¢æŸ¥Bell StateæˆåŠŸæ¢ä»¶
        function checkBellStateSuccess() {
            // åªæœ‰åœ¨M1M2ç™¼å…‰æ™‚ï¼ˆt=3ï¼‰æ‰æª¢æŸ¥
            if (t < 3) {
                return;
            }
            
            // å¦‚æœå·²ç¶“è§¸ç™¼éæˆåŠŸç‰¹æ•ˆï¼Œä¸å†è§¸ç™¼
            if (hasTriggeredBellStateCelebration) {
                return;
            }
            
            // æª¢æŸ¥å…©ç¨®Bell Stateç‹€æ…‹
            // ç‹€æ…‹1: Q1 = (Z1X2,X1) & Q2 = (X2,X1Z2)
            const isState1 = (q1Left === 'Z1X2' || q1Left === 'X2Z1') && 
                           (q1Right === 'X1') && 
                           (q2Left === 'X2') && 
                           (q2Right === 'X1Z2' || q2Right === 'Z2X1');
            
            // ç‹€æ…‹2: Q1 = (X1,X2Z1) & Q2 = (Z2X1,X2)
            const isState2 = (q1Left === 'X1') && 
                           (q1Right === 'X2Z1' || q1Right === 'Z1X2') && 
                           (q2Left === 'Z2X1') && 
                           (q2Right === 'X2');
            
            console.log('Bell State Check:', {
                q1Left, q1Right, q2Left, q2Right,
                isState1, isState2
            });
            
            if (isState1 || isState2) {
                console.log('Bell State achieved! Triggering celebration...');
                hasTriggeredBellStateCelebration = true;
                
                // è§¸ç™¼ç…™èŠ±ç‰¹æ•ˆ
                setTimeout(() => {
                    triggerRealisticFireworks();
                }, 200);
            }
        }
        
        // é¡¯ç¤ºerroræ•ˆæœ
        function showErrorEffect() {
            const runButton = document.querySelector('.run-button');
            const originalBackground = runButton.style.background;
            const originalText = runButton.textContent;
            
            // æ”¹è®ŠæŒ‰éˆ•é¡è‰²å’Œæ–‡å­—
            runButton.style.background = '#ff0000'; // ç´…è‰²
            runButton.textContent = 'ERROR';
            
            // 0.3ç§’å¾Œæ¢å¾©
            setTimeout(() => {
                runButton.style.background = originalBackground;
                runButton.textContent = originalText;
            }, 300);
        }
        
        // é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–éŠæˆ²
        window.addEventListener('load', function() {
            setTimeout(initGame, 100);
            setTimeout(updateDescriptor, 200);
            setTimeout(checkAndUpdateCNOTColors, 300);
            setTimeout(updateTimeStepDisplay, 400); // åˆå§‹åŒ–æ™‚é–“æ­¥é¡¯ç¤º
        });
        
        // éŸ¿æ‡‰å¼èª¿æ•´
        window.addEventListener('resize', function() {
            if (renderer && camera) {
                const container = document.getElementById('game-container');
                const aspect = container.clientWidth / container.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>
